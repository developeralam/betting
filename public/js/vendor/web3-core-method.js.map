{"version":3,"sources":["webpack:///./node_modules/web3-core-method/lib/index.js"],"names":["errors","formatters","utils","promiEvent","Subscriptions","EthersTransactionUtils","Method","options","call","name","Error","this","params","inputFormatter","outputFormatter","transformPayload","extraFormatters","abiCoder","requestManager","accounts","defaultBlock","defaultAccount","transactionBlockTimeout","transactionConfirmationBlocks","transactionPollingTimeout","transactionPollingInterval","blockHeaderTimeout","defaultCommon","defaultChain","defaultHardfork","handleRevert","prototype","setRequestManager","createFunction","func","buildCall","attachToObject","obj","split","length","getCall","args","extractCallback","pop","validateArgs","InvalidNumberOfParams","formatInput","_this","map","formatter","index","formatOutput","result","Array","isArray","res","toPayload","callback","payload","method","_confirmTransaction","defer","promiseResolved","canUnsubscribe","timeoutCount","confirmationCount","intervalId","blockHeaderTimeoutId","lastBlock","gasProvided","gas","isContractDeployment","data","from","to","hasBytecode","_ethereumCalls","inputBlockNumberFormatter","val","outputBlockFormatter","outputTransactionReceiptFormatter","inputAddressFormatter","inputDefaultBlockNumberFormatter","outputTransactionFormatter","type","subscriptions","subscriptionName","_ethereumCall","forEach","mthd","checkConfirmation","existingReceipt","isPolling","err","blockHeader","sub","unsubscribe","clearInterval","clearTimeout","resolve","getTransactionReceipt","catch","_fireError","message","eventEmitter","reject","then","async","receipt","blockHash","receiptFormatter","listeners","block","undefined","latestBlock","getBlockByNumber","latestBlockHash","hash","number","emit","blockNumber","removeAllListeners","contractAddress","NoContractAddressFoundError","code","getCode","status","contractDeployFormatter","ContractCodeNotStoredError","outOfGas","gasUsed","JSON","stringify","revertMessage","txReplayOptions","rawTransactionHex","parsedTx","parse","inputTransactionFormatter","gasLimit","toHexString","gasPrice","value","getRevertReason","TransactionRevertInstructionError","reason","signature","error","TransactionRevertedWithoutReasonError","TransactionOutOfGasError","TransactionError","startWatching","blockHeaderArrived","startInterval","setInterval","bind","provider","on","subscribe","setTimeout","getWallet","wallet","address","privateKey","toLowerCase","_handleTxPricing","tx","Promise","toHex","getGasPrice","all","responses","baseFeePerGas","maxPriorityFeePerGas","maxFeePerGas","toBN","mul","add","isSendTx","isCall","send","slice","arguments","sendTxCallback","reasonData","isRevertReasonString","substring","decodeParameter","RevertInstructionError","e","sendSignedTx","sign","signedPayload","rawTransaction","sendRequest","chain","hardfork","common","signTransaction","txPricing","request","txOptions","self","numberToHex","format","module","exports"],"mappings":"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","file":"js/vendor/web3-core-method.js","sourcesContent":["/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\n'use strict';\nvar errors = require('web3-core-helpers').errors;\nvar formatters = require('web3-core-helpers').formatters;\nvar utils = require('web3-utils');\nvar promiEvent = require('web3-core-promievent');\nvar Subscriptions = require('web3-core-subscriptions').subscriptions;\nvar EthersTransactionUtils = require('@ethersproject/transactions');\nvar Method = function Method(options) {\n    if (!options.call || !options.name) {\n        throw new Error('When creating a method you need to provide at least the \"name\" and \"call\" property.');\n    }\n    this.name = options.name;\n    this.call = options.call;\n    this.params = options.params || 0;\n    this.inputFormatter = options.inputFormatter;\n    this.outputFormatter = options.outputFormatter;\n    this.transformPayload = options.transformPayload;\n    this.extraFormatters = options.extraFormatters;\n    this.abiCoder = options.abiCoder; // Will be used to encode the revert reason string\n    this.requestManager = options.requestManager;\n    // reference to eth.accounts\n    this.accounts = options.accounts;\n    this.defaultBlock = options.defaultBlock || 'latest';\n    this.defaultAccount = options.defaultAccount || null;\n    this.transactionBlockTimeout = options.transactionBlockTimeout || 50;\n    this.transactionConfirmationBlocks = options.transactionConfirmationBlocks || 24;\n    this.transactionPollingTimeout = options.transactionPollingTimeout || 750;\n    this.transactionPollingInterval = options.transactionPollingInterval || 1000;\n    this.blockHeaderTimeout = options.blockHeaderTimeout || 10; // 10 seconds\n    this.defaultCommon = options.defaultCommon;\n    this.defaultChain = options.defaultChain;\n    this.defaultHardfork = options.defaultHardfork;\n    this.handleRevert = options.handleRevert;\n};\nMethod.prototype.setRequestManager = function (requestManager, accounts) {\n    this.requestManager = requestManager;\n    // reference to eth.accounts\n    if (accounts) {\n        this.accounts = accounts;\n    }\n};\nMethod.prototype.createFunction = function (requestManager, accounts) {\n    var func = this.buildCall();\n    func.call = this.call;\n    this.setRequestManager(requestManager || this.requestManager, accounts || this.accounts);\n    return func;\n};\nMethod.prototype.attachToObject = function (obj) {\n    var func = this.buildCall();\n    func.call = this.call;\n    var name = this.name.split('.');\n    if (name.length > 1) {\n        obj[name[0]] = obj[name[0]] || {};\n        obj[name[0]][name[1]] = func;\n    }\n    else {\n        obj[name[0]] = func;\n    }\n};\n/**\n * Should be used to determine name of the jsonrpc method based on arguments\n *\n * @method getCall\n * @param {Array} arguments\n * @return {String} name of jsonrpc method\n */\nMethod.prototype.getCall = function (args) {\n    return typeof this.call === 'function' ? this.call(args) : this.call;\n};\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\nMethod.prototype.extractCallback = function (args) {\n    if (typeof (args[args.length - 1]) === 'function') {\n        return args.pop(); // modify the args array!\n    }\n};\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\nMethod.prototype.validateArgs = function (args) {\n    if (args.length !== this.params) {\n        throw errors.InvalidNumberOfParams(args.length, this.params, this.name);\n    }\n};\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\nMethod.prototype.formatInput = function (args) {\n    var _this = this;\n    if (!this.inputFormatter) {\n        return args;\n    }\n    return this.inputFormatter.map(function (formatter, index) {\n        // bind this for defaultBlock, and defaultAccount\n        return formatter ? formatter.call(_this, args[index]) : args[index];\n    });\n};\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param {Object}\n * @return {Object}\n */\nMethod.prototype.formatOutput = function (result) {\n    var _this = this;\n    if (Array.isArray(result)) {\n        return result.map(function (res) {\n            return _this.outputFormatter && res ? _this.outputFormatter(res) : res;\n        });\n    }\n    else {\n        return this.outputFormatter && result ? this.outputFormatter(result) : result;\n    }\n};\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\nMethod.prototype.toPayload = function (args) {\n    var call = this.getCall(args);\n    var callback = this.extractCallback(args);\n    var params = this.formatInput(args);\n    this.validateArgs(params);\n    var payload = {\n        method: call,\n        params: params,\n        callback: callback\n    };\n    if (this.transformPayload) {\n        payload = this.transformPayload(payload);\n    }\n    return payload;\n};\nMethod.prototype._confirmTransaction = function (defer, result, payload) {\n    var method = this, promiseResolved = false, canUnsubscribe = true, timeoutCount = 0, confirmationCount = 0, intervalId = null, blockHeaderTimeoutId = null, lastBlock = null, receiptJSON = '', gasProvided = ((!!payload.params[0] && typeof payload.params[0] === 'object') && payload.params[0].gas) ? payload.params[0].gas : null, isContractDeployment = (!!payload.params[0] && typeof payload.params[0] === 'object') &&\n        payload.params[0].data &&\n        payload.params[0].from &&\n        !payload.params[0].to, hasBytecode = isContractDeployment && payload.params[0].data.length > 2;\n    // add custom send Methods\n    var _ethereumCalls = [\n        new Method({\n            name: 'getBlockByNumber',\n            call: 'eth_getBlockByNumber',\n            params: 2,\n            inputFormatter: [formatters.inputBlockNumberFormatter, function (val) {\n                    return !!val;\n                }],\n            outputFormatter: formatters.outputBlockFormatter\n        }),\n        new Method({\n            name: 'getTransactionReceipt',\n            call: 'eth_getTransactionReceipt',\n            params: 1,\n            inputFormatter: [null],\n            outputFormatter: formatters.outputTransactionReceiptFormatter\n        }),\n        new Method({\n            name: 'getCode',\n            call: 'eth_getCode',\n            params: 2,\n            inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]\n        }),\n        new Method({\n            name: 'getTransactionByHash',\n            call: 'eth_getTransactionByHash',\n            params: 1,\n            inputFormatter: [null],\n            outputFormatter: formatters.outputTransactionFormatter\n        }),\n        new Subscriptions({\n            name: 'subscribe',\n            type: 'eth',\n            subscriptions: {\n                'newBlockHeaders': {\n                    subscriptionName: 'newHeads',\n                    params: 0,\n                    outputFormatter: formatters.outputBlockFormatter\n                }\n            }\n        })\n    ];\n    // attach methods to this._ethereumCall\n    var _ethereumCall = {};\n    _ethereumCalls.forEach(mthd => {\n        mthd.attachToObject(_ethereumCall);\n        mthd.requestManager = method.requestManager; // assign rather than call setRequestManager()\n    });\n    // fire \"receipt\" and confirmation events and resolve after\n    var checkConfirmation = function (existingReceipt, isPolling, err, blockHeader, sub) {\n        if (!err) {\n            // create fake unsubscribe\n            if (!sub) {\n                sub = {\n                    unsubscribe: function () {\n                        clearInterval(intervalId);\n                        clearTimeout(blockHeaderTimeoutId);\n                    }\n                };\n            }\n            // if we have a valid receipt we don't need to send a request\n            return (existingReceipt ? promiEvent.resolve(existingReceipt) : _ethereumCall.getTransactionReceipt(result))\n                // catch error from requesting receipt\n                .catch(function (err) {\n                sub.unsubscribe();\n                promiseResolved = true;\n                utils._fireError({\n                    message: 'Failed to check for transaction receipt:',\n                    data: err\n                }, defer.eventEmitter, defer.reject);\n            })\n                // if CONFIRMATION listener exists check for confirmations, by setting canUnsubscribe = false\n                .then(async function (receipt) {\n                if (!receipt || !receipt.blockHash) {\n                    throw new Error('Receipt missing or blockHash null');\n                }\n                // apply extra formatters\n                if (method.extraFormatters && method.extraFormatters.receiptFormatter) {\n                    receipt = method.extraFormatters.receiptFormatter(receipt);\n                }\n                // check if confirmation listener exists\n                if (defer.eventEmitter.listeners('confirmation').length > 0) {\n                    var block;\n                    // If there was an immediately retrieved receipt, it's already\n                    // been confirmed by the direct call to checkConfirmation needed\n                    // for parity instant-seal\n                    if (existingReceipt === undefined || confirmationCount !== 0) {\n                        // Get latest block to emit with confirmation\n                        var latestBlock = await _ethereumCall.getBlockByNumber('latest');\n                        var latestBlockHash = latestBlock ? latestBlock.hash : null;\n                        if (isPolling) { // Check if actually a new block is existing on polling\n                            if (lastBlock) {\n                                block = await _ethereumCall.getBlockByNumber(lastBlock.number + 1);\n                                if (block) {\n                                    lastBlock = block;\n                                    defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n                                }\n                            }\n                            else {\n                                block = await _ethereumCall.getBlockByNumber(receipt.blockNumber);\n                                lastBlock = block;\n                                defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n                            }\n                        }\n                        else {\n                            defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n                        }\n                    }\n                    if ((isPolling && block) || !isPolling) {\n                        confirmationCount++;\n                    }\n                    canUnsubscribe = false;\n                    if (confirmationCount === method.transactionConfirmationBlocks + 1) { // add 1 so we account for conf 0\n                        sub.unsubscribe();\n                        defer.eventEmitter.removeAllListeners();\n                    }\n                }\n                return receipt;\n            })\n                // CHECK for CONTRACT DEPLOYMENT\n                .then(async function (receipt) {\n                if (isContractDeployment && !promiseResolved) {\n                    if (!receipt.contractAddress) {\n                        if (canUnsubscribe) {\n                            sub.unsubscribe();\n                            promiseResolved = true;\n                        }\n                        utils._fireError(errors.NoContractAddressFoundError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                        return;\n                    }\n                    var code;\n                    try {\n                        code = await _ethereumCall.getCode(receipt.contractAddress);\n                    }\n                    catch (err) {\n                        // ignore;\n                    }\n                    if (!code) {\n                        return;\n                    }\n                    // If deployment is status.true and there was a real\n                    // bytecode string, assume it was successful.\n                    var deploymentSuccess = receipt.status === true && hasBytecode;\n                    if (deploymentSuccess || code.length > 2) {\n                        defer.eventEmitter.emit('receipt', receipt);\n                        // if contract, return instance instead of receipt\n                        if (method.extraFormatters && method.extraFormatters.contractDeployFormatter) {\n                            defer.resolve(method.extraFormatters.contractDeployFormatter(receipt));\n                        }\n                        else {\n                            defer.resolve(receipt);\n                        }\n                        // need to remove listeners, as they aren't removed automatically when succesfull\n                        if (canUnsubscribe) {\n                            defer.eventEmitter.removeAllListeners();\n                        }\n                    }\n                    else {\n                        utils._fireError(errors.ContractCodeNotStoredError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                    }\n                    if (canUnsubscribe) {\n                        sub.unsubscribe();\n                    }\n                    promiseResolved = true;\n                }\n                return receipt;\n            })\n                // CHECK for normal tx check for receipt only\n                .then(async function (receipt) {\n                if (!isContractDeployment && !promiseResolved) {\n                    if (!receipt.outOfGas &&\n                        (!gasProvided || gasProvided !== receipt.gasUsed) &&\n                        (receipt.status === true || receipt.status === '0x1' || typeof receipt.status === 'undefined')) {\n                        defer.eventEmitter.emit('receipt', receipt);\n                        defer.resolve(receipt);\n                        // need to remove listeners, as they aren't removed automatically when succesfull\n                        if (canUnsubscribe) {\n                            defer.eventEmitter.removeAllListeners();\n                        }\n                    }\n                    else {\n                        receiptJSON = JSON.stringify(receipt, null, 2);\n                        if (receipt.status === false || receipt.status === '0x0') {\n                            try {\n                                var revertMessage = null;\n                                if (method.handleRevert &&\n                                    (method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction')) {\n                                    var txReplayOptions = payload.params[0];\n                                    // If send was raw, fetch the transaction and reconstitute the\n                                    // original params so they can be replayed with `eth_call`\n                                    if (method.call === 'eth_sendRawTransaction') {\n                                        var rawTransactionHex = payload.params[0];\n                                        var parsedTx = EthersTransactionUtils.parse(rawTransactionHex);\n                                        txReplayOptions = formatters.inputTransactionFormatter({\n                                            data: parsedTx.data,\n                                            to: parsedTx.to,\n                                            from: parsedTx.from,\n                                            gas: parsedTx.gasLimit.toHexString(),\n                                            gasPrice: parsedTx.gasPrice.toHexString(),\n                                            value: parsedTx.value.toHexString()\n                                        });\n                                    }\n                                    // Get revert reason string with eth_call\n                                    revertMessage = await method.getRevertReason(txReplayOptions, receipt.blockNumber);\n                                    if (revertMessage) { // Only throw a revert error if a revert reason is existing\n                                        utils._fireError(errors.TransactionRevertInstructionError(revertMessage.reason, revertMessage.signature, receipt), defer.eventEmitter, defer.reject, null, receipt);\n                                    }\n                                    else {\n                                        throw false; // Throw false and let the try/catch statement handle the error correctly after\n                                    }\n                                }\n                                else {\n                                    throw false; // Throw false and let the try/catch statement handle the error correctly after\n                                }\n                            }\n                            catch (error) {\n                                // Throw an normal revert error if no revert reason is given or the detection of it is disabled\n                                utils._fireError(errors.TransactionRevertedWithoutReasonError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                            }\n                        }\n                        else {\n                            // Throw OOG if status is not existing and provided gas and used gas are equal\n                            utils._fireError(errors.TransactionOutOfGasError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                        }\n                    }\n                    if (canUnsubscribe) {\n                        sub.unsubscribe();\n                    }\n                    promiseResolved = true;\n                }\n            })\n                // time out the transaction if not mined after 50 blocks\n                .catch(function () {\n                timeoutCount++;\n                // check to see if we are http polling\n                if (!!isPolling) {\n                    // polling timeout is different than transactionBlockTimeout blocks since we are triggering every second\n                    if (timeoutCount - 1 >= method.transactionPollingTimeout) {\n                        sub.unsubscribe();\n                        promiseResolved = true;\n                        utils._fireError(errors.TransactionError('Transaction was not mined within ' + method.transactionPollingTimeout + ' seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n                    }\n                }\n                else {\n                    if (timeoutCount - 1 >= method.transactionBlockTimeout) {\n                        sub.unsubscribe();\n                        promiseResolved = true;\n                        utils._fireError(errors.TransactionError('Transaction was not mined within ' + method.transactionBlockTimeout + ' blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n                    }\n                }\n            });\n        }\n        else {\n            sub.unsubscribe();\n            promiseResolved = true;\n            utils._fireError({\n                message: 'Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.',\n                data: err\n            }, defer.eventEmitter, defer.reject);\n        }\n    };\n    // start watching for confirmation depending on the support features of the provider\n    var startWatching = function (existingReceipt) {\n        let blockHeaderArrived = false;\n        const startInterval = () => {\n            intervalId = setInterval(checkConfirmation.bind(null, existingReceipt, true), method.transactionPollingInterval);\n        };\n        // If provider do not support event subscription use polling\n        if (!this.requestManager.provider.on) {\n            return startInterval();\n        }\n        // Subscribe to new block headers to look for tx receipt\n        _ethereumCall.subscribe('newBlockHeaders', function (err, blockHeader, sub) {\n            blockHeaderArrived = true;\n            if (err || !blockHeader) {\n                // fall back to polling\n                return startInterval();\n            }\n            checkConfirmation(existingReceipt, false, err, blockHeader, sub);\n        });\n        // Fallback to polling if tx receipt didn't arrived in \"blockHeaderTimeout\" [10 seconds]\n        blockHeaderTimeoutId = setTimeout(() => {\n            if (!blockHeaderArrived) {\n                startInterval();\n            }\n        }, this.blockHeaderTimeout * 1000);\n    }.bind(this);\n    // first check if we already have a confirmed transaction\n    _ethereumCall.getTransactionReceipt(result)\n        .then(function (receipt) {\n        if (receipt && receipt.blockHash) {\n            if (defer.eventEmitter.listeners('confirmation').length > 0) {\n                // We must keep on watching for new Blocks, if a confirmation listener is present\n                startWatching(receipt);\n            }\n            checkConfirmation(receipt, false);\n        }\n        else if (!promiseResolved) {\n            startWatching();\n        }\n    })\n        .catch(function () {\n        if (!promiseResolved)\n            startWatching();\n    });\n};\nvar getWallet = function (from, accounts) {\n    var wallet = null;\n    // is index given\n    if (typeof from === 'number') {\n        wallet = accounts.wallet[from];\n        // is account given\n    }\n    else if (!!from && typeof from === 'object' && from.address && from.privateKey) {\n        wallet = from;\n        // search in wallet for address\n    }\n    else {\n        wallet = accounts.wallet[from.toLowerCase()];\n    }\n    return wallet;\n};\nMethod.prototype.buildCall = function () {\n    var method = this, isSendTx = (method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction'), // || method.call === 'personal_sendTransaction'\n    isCall = (method.call === 'eth_call');\n    // actual send function\n    var send = function () {\n        var defer = promiEvent(!isSendTx), payload = method.toPayload(Array.prototype.slice.call(arguments));\n        // CALLBACK function\n        var sendTxCallback = function (err, result) {\n            if (method.handleRevert && isCall && method.abiCoder) {\n                var reasonData;\n                // Ganache / Geth <= 1.9.13 return the reason data as a successful eth_call response\n                // Geth >= 1.9.15 attaches the reason data to an error object.\n                // Geth 1.9.14 is missing revert reason (https://github.com/ethereum/web3.js/issues/3520)\n                if (!err && method.isRevertReasonString(result)) {\n                    reasonData = result.substring(10);\n                }\n                else if (err && err.data) {\n                    reasonData = err.data.substring(10);\n                }\n                if (reasonData) {\n                    var reason = method.abiCoder.decodeParameter('string', '0x' + reasonData);\n                    var signature = 'Error(String)';\n                    utils._fireError(errors.RevertInstructionError(reason, signature), defer.eventEmitter, defer.reject, payload.callback, {\n                        reason: reason,\n                        signature: signature\n                    });\n                    return;\n                }\n            }\n            try {\n                result = method.formatOutput(result);\n            }\n            catch (e) {\n                err = e;\n            }\n            if (result instanceof Error) {\n                err = result;\n            }\n            if (!err) {\n                if (payload.callback) {\n                    payload.callback(null, result);\n                }\n            }\n            else {\n                if (err.error) {\n                    err = err.error;\n                }\n                return utils._fireError(err, defer.eventEmitter, defer.reject, payload.callback);\n            }\n            // return PROMISE\n            if (!isSendTx) {\n                if (!err) {\n                    defer.resolve(result);\n                }\n                // return PROMIEVENT\n            }\n            else {\n                defer.eventEmitter.emit('transactionHash', result);\n                method._confirmTransaction(defer, result, payload);\n            }\n        };\n        // SENDS the SIGNED SIGNATURE\n        var sendSignedTx = function (sign) {\n            var signedPayload = { ...payload,\n                method: 'eth_sendRawTransaction',\n                params: [sign.rawTransaction]\n            };\n            method.requestManager.send(signedPayload, sendTxCallback);\n        };\n        var sendRequest = function (payload, method) {\n            if (method && method.accounts && method.accounts.wallet && method.accounts.wallet.length) {\n                var wallet;\n                // ETH_SENDTRANSACTION\n                if (payload.method === 'eth_sendTransaction') {\n                    var tx = payload.params[0];\n                    wallet = getWallet((!!tx && typeof tx === 'object') ? tx.from : null, method.accounts);\n                    // If wallet was found, sign tx, and send using sendRawTransaction\n                    if (wallet && wallet.privateKey) {\n                        var tx = JSON.parse(JSON.stringify(tx));\n                        delete tx.from;\n                        if (method.defaultChain && !tx.chain) {\n                            tx.chain = method.defaultChain;\n                        }\n                        if (method.defaultHardfork && !tx.hardfork) {\n                            tx.hardfork = method.defaultHardfork;\n                        }\n                        if (method.defaultCommon && !tx.common) {\n                            tx.common = method.defaultCommon;\n                        }\n                        method.accounts.signTransaction(tx, wallet.privateKey)\n                            .then(sendSignedTx)\n                            .catch(function (err) {\n                            if (typeof defer.eventEmitter.listeners === 'function' && defer.eventEmitter.listeners('error').length) {\n                                try {\n                                    defer.eventEmitter.emit('error', err);\n                                }\n                                catch (err) {\n                                    // Ignore userland error prevent it to bubble up within web3.\n                                }\n                                defer.eventEmitter.removeAllListeners();\n                                defer.eventEmitter.catch(function () {\n                                });\n                            }\n                            defer.reject(err);\n                        });\n                        return;\n                    }\n                    // ETH_SIGN\n                }\n                else if (payload.method === 'eth_sign') {\n                    var data = payload.params[1];\n                    wallet = getWallet(payload.params[0], method.accounts);\n                    // If wallet was found, sign tx, and send using sendRawTransaction\n                    if (wallet && wallet.privateKey) {\n                        var sign = method.accounts.sign(data, wallet.privateKey);\n                        if (payload.callback) {\n                            payload.callback(null, sign.signature);\n                        }\n                        defer.resolve(sign.signature);\n                        return;\n                    }\n                }\n            }\n            return method.requestManager.send(payload, sendTxCallback);\n        };\n        // Send the actual transaction\n        if (isSendTx\n            && !!payload.params[0]\n            && typeof payload.params[0] === 'object'\n            && (typeof payload.params[0].gasPrice === 'undefined'\n                && (typeof payload.params[0].maxPriorityFeePerGas === 'undefined'\n                    || typeof payload.params[0].maxFeePerGas === 'undefined'))) {\n            _handleTxPricing(method, payload.params[0]).then(txPricing => {\n                if (txPricing.gasPrice !== undefined) {\n                    payload.params[0].gasPrice = txPricing.gasPrice;\n                }\n                else if (txPricing.maxPriorityFeePerGas !== undefined\n                    && txPricing.maxFeePerGas !== undefined) {\n                    payload.params[0].maxPriorityFeePerGas = txPricing.maxPriorityFeePerGas;\n                    payload.params[0].maxFeePerGas = txPricing.maxFeePerGas;\n                }\n                if (isSendTx) {\n                    setTimeout(() => {\n                        defer.eventEmitter.emit('sending', payload);\n                    }, 0);\n                }\n                sendRequest(payload, method);\n            });\n        }\n        else {\n            if (isSendTx) {\n                setTimeout(() => {\n                    defer.eventEmitter.emit('sending', payload);\n                }, 0);\n            }\n            sendRequest(payload, method);\n        }\n        if (isSendTx) {\n            setTimeout(() => {\n                defer.eventEmitter.emit('sent', payload);\n            }, 0);\n        }\n        return defer.eventEmitter;\n    };\n    // necessary to attach things to the method\n    send.method = method;\n    // necessary for batch requests\n    send.request = this.request.bind(this);\n    return send;\n};\nfunction _handleTxPricing(method, tx) {\n    return new Promise((resolve, reject) => {\n        try {\n            var getBlockByNumber = (new Method({\n                name: 'getBlockByNumber',\n                call: 'eth_getBlockByNumber',\n                params: 2,\n                inputFormatter: [function (blockNumber) {\n                        return blockNumber ? utils.toHex(blockNumber) : 'latest';\n                    }, function () {\n                        return false;\n                    }]\n            })).createFunction(method.requestManager);\n            var getGasPrice = (new Method({\n                name: 'getGasPrice',\n                call: 'eth_gasPrice',\n                params: 0\n            })).createFunction(method.requestManager);\n            Promise.all([\n                getBlockByNumber(),\n                getGasPrice()\n            ]).then(responses => {\n                const [block, gasPrice] = responses;\n                if ((tx.type === '0x2' || tx.type === undefined) &&\n                    (block && block.baseFeePerGas)) {\n                    // The network supports EIP-1559\n                    // Taken from https://github.com/ethers-io/ethers.js/blob/ba6854bdd5a912fe873d5da494cb5c62c190adde/packages/abstract-provider/src.ts/index.ts#L230\n                    let maxPriorityFeePerGas, maxFeePerGas;\n                    if (tx.gasPrice) {\n                        // Using legacy gasPrice property on an eip-1559 network,\n                        // so use gasPrice as both fee properties\n                        maxPriorityFeePerGas = tx.gasPrice;\n                        maxFeePerGas = tx.gasPrice;\n                        delete tx.gasPrice;\n                    }\n                    else {\n                        maxPriorityFeePerGas = tx.maxPriorityFeePerGas || '0x9502F900'; // 2.5 Gwei\n                        maxFeePerGas = tx.maxFeePerGas ||\n                            utils.toHex(utils.toBN(block.baseFeePerGas)\n                                .mul(utils.toBN(2))\n                                .add(utils.toBN(maxPriorityFeePerGas)));\n                    }\n                    resolve({ maxFeePerGas, maxPriorityFeePerGas });\n                }\n                else {\n                    if (tx.maxPriorityFeePerGas || tx.maxFeePerGas)\n                        throw Error(\"Network doesn't support eip-1559\");\n                    resolve({ gasPrice });\n                }\n            });\n        }\n        catch (error) {\n            reject(error);\n        }\n    });\n}\n/**\n * Returns the revert reason string if existing or otherwise false.\n *\n * @method getRevertReason\n *\n * @param {Object} txOptions\n * @param {Number} blockNumber\n *\n * @returns {Promise<Boolean|String>}\n */\nMethod.prototype.getRevertReason = function (txOptions, blockNumber) {\n    var self = this;\n    return new Promise(function (resolve, reject) {\n        (new Method({\n            name: 'call',\n            call: 'eth_call',\n            params: 2,\n            abiCoder: self.abiCoder,\n            handleRevert: true\n        }))\n            .createFunction(self.requestManager)(txOptions, utils.numberToHex(blockNumber))\n            .then(function () {\n            resolve(false);\n        })\n            .catch(function (error) {\n            if (error.reason) {\n                resolve({\n                    reason: error.reason,\n                    signature: error.signature\n                });\n            }\n            else {\n                reject(error);\n            }\n        });\n    });\n};\n/**\n * Checks if the given hex string is a revert message from the EVM\n *\n * @method isRevertReasonString\n *\n * @param {String} data - Hex string prefixed with 0x\n *\n * @returns {Boolean}\n */\nMethod.prototype.isRevertReasonString = function (data) {\n    return typeof data === 'string' && ((data.length - 2) / 2) % 32 === 4 && data.substring(0, 10) === '0x08c379a0';\n};\n/**\n * Should be called to create the pure JSONRPC request which can be used in a batch request\n *\n * @method request\n * @return {Object} jsonrpc request\n */\nMethod.prototype.request = function () {\n    var payload = this.toPayload(Array.prototype.slice.call(arguments));\n    payload.format = this.formatOutput.bind(this);\n    return payload;\n};\nmodule.exports = Method;\n"],"sourceRoot":""}