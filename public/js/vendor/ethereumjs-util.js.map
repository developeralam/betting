{"version":3,"sources":["webpack:///./node_modules/ethereumjs-util/dist.browser/account.js","webpack:///./node_modules/ethereumjs-util/dist.browser/address.js","webpack:///./node_modules/ethereumjs-util/dist.browser/bytes.js","webpack:///./node_modules/ethereumjs-util/dist.browser/constants.js","webpack:///./node_modules/ethereumjs-util/dist.browser/externals.js","webpack:///./node_modules/ethereumjs-util/dist.browser/hash.js","webpack:///./node_modules/ethereumjs-util/dist.browser/helpers.js","webpack:///./node_modules/ethereumjs-util/dist.browser/index.js","webpack:///./node_modules/ethereumjs-util/dist.browser/internal.js","webpack:///./node_modules/ethereumjs-util/dist.browser/object.js","webpack:///./node_modules/ethereumjs-util/dist.browser/signature.js","webpack:///./node_modules/ethereumjs-util/dist.browser/types.js"],"names":["__read","this","o","n","m","Symbol","iterator","r","e","i","call","ar","next","done","push","value","error","__importDefault","mod","__esModule","Object","defineProperty","exports","isZeroAddress","zeroAddress","importPublic","privateToAddress","privateToPublic","publicToAddress","pubToAddress","isValidPublic","isValidPrivate","generateAddress2","generateAddress","isValidChecksumAddress","toChecksumAddress","isValidAddress","Account","assert_1","externals_1","secp256k1_1","internal_1","constants_1","bytes_1","hash_1","helpers_1","types_1","nonce","balance","stateRoot","codeHash","BN","KECCAK256_RLP","KECCAK256_NULL","_validate","fromAccountData","accountData","toBuffer","undefined","fromRlpSerializedAccount","serialized","values","rlp","decode","Array","isArray","Error","fromValuesArray","_a","prototype","lt","length","raw","bnToUnpaddedBuffer","serialize","encode","isContract","equals","isEmpty","isZero","hexAddress","assertIsString","test","eip1191ChainId","assertIsHexString","address","stripHexPrefix","toLowerCase","prefix","toType","TypeOutput","toString","hash","keccakFromString","ret","parseInt","toUpperCase","from","assertIsBuffer","nonceBN","rlphash","slice","Buffer","toArray","salt","initCode","default","keccak256","concat","privateKey","privateKeyVerify","publicKey","sanitize","publicKeyVerify","pubKey","publicKeyConvert","keccak","publicKeyCreate","addr","zeros","bufferToHex","Address","account_1","buf","zero","fromString","str","fromPublicKey","isBuffer","fromPrivateKey","generate","isBN","toArrayLike","generate2","isPrecompileOrSystemAddress","addressBN","rangeMin","rangeMax","gte","lte","__values","s","TypeError","bufArrToArr","arrToBufArr","validateNoLeadingZeroes","baToJSON","toUtf8","addHexPrefix","toUnsigned","fromSigned","bufferToInt","unpadHexString","unpadArray","unpadBuffer","setLengthRight","setLengthLeft","intToBuffer","intToHex","Number","isSafeInteger","hex","padToEven","bytes","allocUnsafe","fill","setLength","msg","right","copy","stripZeros","a","first","assertIsArray","v","Uint8Array","isHexString","isNeg","toNumber","num","fromTwos","toTwos","isHexPrefixed","replace","ba","array","e_1","_b","entries","_c","_d","k","e_1_1","return","arr","map","KECCAK256_RLP_S","KECCAK256_RLP_ARRAY","KECCAK256_RLP_ARRAY_S","KECCAK256_NULL_S","TWO_POW256","MAX_INTEGER","MAX_UINT64","buffer_1","__createBinding","create","k2","enumerable","get","__setModuleDefault","__importStar","result","hasOwnProperty","bn_js_1","ripemd160FromArray","ripemd160FromString","ripemd160","sha256FromArray","sha256FromString","sha256","keccakFromArray","keccakFromHexString","keccak_1","createHash","bits","keccak224","keccak384","keccak512","_sha256","update","digest","_ripemd160","padded","input","__exportStar","p","getKeys","fromAscii","fromUtf8","toAscii","arrayContainsArray","getBinarySize","byteLength","superset","subset","some","indexOf","l","substring","code","substr","String","fromCharCode","stringValue","charCodeAt","params","key","allowEmpty","match","defineProperties","self","fields","data","_fields","toJSON","label","obj_1","forEach","field","getter","setter","allowZero","allowLess","name","configurable","set","alias","d","keys_1","keys","hashPersonalMessage","isValidSignature","fromRpcSig","toCompactSig","toRpcSig","ecrecover","ecsign","calculateSigRecovery","chainId","vBN","subn","chainIdBN","sub","muln","addn","isValidSigRecovery","recovery","rec","eqn","msgHash","ecdsaSign","signature","recid","senderPubKey","ecdsaRecover","vn","ss","sig","homesteadOrLater","SECP256K1_N_DIV_2","SECP256K1_N","rBN","sBN","gt","cmp","message","bnToRlp","bnToHex","outputType","output","bn","max","MAX_SAFE_INTEGER"],"mappings":"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","file":"js/vendor/ethereumjs-util.js","sourcesContent":["\"use strict\";\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;\nvar assert_1 = __importDefault(require(\"assert\"));\nvar externals_1 = require(\"./externals\");\nvar secp256k1_1 = require(\"ethereum-cryptography/secp256k1\");\nvar internal_1 = require(\"./internal\");\nvar constants_1 = require(\"./constants\");\nvar bytes_1 = require(\"./bytes\");\nvar hash_1 = require(\"./hash\");\nvar helpers_1 = require(\"./helpers\");\nvar types_1 = require(\"./types\");\nvar Account = /** @class */ (function () {\n    /**\n     * This constructor assigns and validates the values.\n     * Use the static factory methods to assist in creating an Account from varying data types.\n     */\n    function Account(nonce, balance, stateRoot, codeHash) {\n        if (nonce === void 0) { nonce = new externals_1.BN(0); }\n        if (balance === void 0) { balance = new externals_1.BN(0); }\n        if (stateRoot === void 0) { stateRoot = constants_1.KECCAK256_RLP; }\n        if (codeHash === void 0) { codeHash = constants_1.KECCAK256_NULL; }\n        this.nonce = nonce;\n        this.balance = balance;\n        this.stateRoot = stateRoot;\n        this.codeHash = codeHash;\n        this._validate();\n    }\n    Account.fromAccountData = function (accountData) {\n        var nonce = accountData.nonce, balance = accountData.balance, stateRoot = accountData.stateRoot, codeHash = accountData.codeHash;\n        return new Account(nonce ? new externals_1.BN((0, bytes_1.toBuffer)(nonce)) : undefined, balance ? new externals_1.BN((0, bytes_1.toBuffer)(balance)) : undefined, stateRoot ? (0, bytes_1.toBuffer)(stateRoot) : undefined, codeHash ? (0, bytes_1.toBuffer)(codeHash) : undefined);\n    };\n    Account.fromRlpSerializedAccount = function (serialized) {\n        var values = externals_1.rlp.decode(serialized);\n        if (!Array.isArray(values)) {\n            throw new Error('Invalid serialized account input. Must be array');\n        }\n        return this.fromValuesArray(values);\n    };\n    Account.fromValuesArray = function (values) {\n        var _a = __read(values, 4), nonce = _a[0], balance = _a[1], stateRoot = _a[2], codeHash = _a[3];\n        return new Account(new externals_1.BN(nonce), new externals_1.BN(balance), stateRoot, codeHash);\n    };\n    Account.prototype._validate = function () {\n        if (this.nonce.lt(new externals_1.BN(0))) {\n            throw new Error('nonce must be greater than zero');\n        }\n        if (this.balance.lt(new externals_1.BN(0))) {\n            throw new Error('balance must be greater than zero');\n        }\n        if (this.stateRoot.length !== 32) {\n            throw new Error('stateRoot must have a length of 32');\n        }\n        if (this.codeHash.length !== 32) {\n            throw new Error('codeHash must have a length of 32');\n        }\n    };\n    /**\n     * Returns a Buffer Array of the raw Buffers for the account, in order.\n     */\n    Account.prototype.raw = function () {\n        return [\n            (0, types_1.bnToUnpaddedBuffer)(this.nonce),\n            (0, types_1.bnToUnpaddedBuffer)(this.balance),\n            this.stateRoot,\n            this.codeHash,\n        ];\n    };\n    /**\n     * Returns the RLP serialization of the account as a `Buffer`.\n     */\n    Account.prototype.serialize = function () {\n        return externals_1.rlp.encode(this.raw());\n    };\n    /**\n     * Returns a `Boolean` determining if the account is a contract.\n     */\n    Account.prototype.isContract = function () {\n        return !this.codeHash.equals(constants_1.KECCAK256_NULL);\n    };\n    /**\n     * Returns a `Boolean` determining if the account is empty complying to the definition of\n     * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n     * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n     */\n    Account.prototype.isEmpty = function () {\n        return this.balance.isZero() && this.nonce.isZero() && this.codeHash.equals(constants_1.KECCAK256_NULL);\n    };\n    return Account;\n}());\nexports.Account = Account;\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\nvar isValidAddress = function (hexAddress) {\n    try {\n        (0, helpers_1.assertIsString)(hexAddress);\n    }\n    catch (e) {\n        return false;\n    }\n    return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\n};\nexports.isValidAddress = isValidAddress;\n/**\n * Returns a checksummed address.\n *\n * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not\n * backwards compatible to the original widely adopted checksum format standard introduced in\n * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.\n * Usage of this EIP is therefore discouraged unless you have a very targeted use case.\n */\nvar toChecksumAddress = function (hexAddress, eip1191ChainId) {\n    (0, helpers_1.assertIsHexString)(hexAddress);\n    var address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();\n    var prefix = '';\n    if (eip1191ChainId) {\n        var chainId = (0, types_1.toType)(eip1191ChainId, types_1.TypeOutput.BN);\n        prefix = chainId.toString() + '0x';\n    }\n    var hash = (0, hash_1.keccakFromString)(prefix + address).toString('hex');\n    var ret = '0x';\n    for (var i = 0; i < address.length; i++) {\n        if (parseInt(hash[i], 16) >= 8) {\n            ret += address[i].toUpperCase();\n        }\n        else {\n            ret += address[i];\n        }\n    }\n    return ret;\n};\nexports.toChecksumAddress = toChecksumAddress;\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\nvar isValidChecksumAddress = function (hexAddress, eip1191ChainId) {\n    return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;\n};\nexports.isValidChecksumAddress = isValidChecksumAddress;\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nvar generateAddress = function (from, nonce) {\n    (0, helpers_1.assertIsBuffer)(from);\n    (0, helpers_1.assertIsBuffer)(nonce);\n    var nonceBN = new externals_1.BN(nonce);\n    if (nonceBN.isZero()) {\n        // in RLP we want to encode null in the case of zero nonce\n        // read the RLP documentation for an answer if you dare\n        return (0, hash_1.rlphash)([from, null]).slice(-20);\n    }\n    // Only take the lower 160bits of the hash\n    return (0, hash_1.rlphash)([from, Buffer.from(nonceBN.toArray())]).slice(-20);\n};\nexports.generateAddress = generateAddress;\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nvar generateAddress2 = function (from, salt, initCode) {\n    (0, helpers_1.assertIsBuffer)(from);\n    (0, helpers_1.assertIsBuffer)(salt);\n    (0, helpers_1.assertIsBuffer)(initCode);\n    (0, assert_1.default)(from.length === 20);\n    (0, assert_1.default)(salt.length === 32);\n    var address = (0, hash_1.keccak256)(Buffer.concat([Buffer.from('ff', 'hex'), from, salt, (0, hash_1.keccak256)(initCode)]));\n    return address.slice(-20);\n};\nexports.generateAddress2 = generateAddress2;\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\nvar isValidPrivate = function (privateKey) {\n    return (0, secp256k1_1.privateKeyVerify)(privateKey);\n};\nexports.isValidPrivate = isValidPrivate;\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nvar isValidPublic = function (publicKey, sanitize) {\n    if (sanitize === void 0) { sanitize = false; }\n    (0, helpers_1.assertIsBuffer)(publicKey);\n    if (publicKey.length === 64) {\n        // Convert to SEC1 for secp256k1\n        return (0, secp256k1_1.publicKeyVerify)(Buffer.concat([Buffer.from([4]), publicKey]));\n    }\n    if (!sanitize) {\n        return false;\n    }\n    return (0, secp256k1_1.publicKeyVerify)(publicKey);\n};\nexports.isValidPublic = isValidPublic;\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nvar pubToAddress = function (pubKey, sanitize) {\n    if (sanitize === void 0) { sanitize = false; }\n    (0, helpers_1.assertIsBuffer)(pubKey);\n    if (sanitize && pubKey.length !== 64) {\n        pubKey = Buffer.from((0, secp256k1_1.publicKeyConvert)(pubKey, false).slice(1));\n    }\n    (0, assert_1.default)(pubKey.length === 64);\n    // Only take the lower 160bits of the hash\n    return (0, hash_1.keccak)(pubKey).slice(-20);\n};\nexports.pubToAddress = pubToAddress;\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nvar privateToPublic = function (privateKey) {\n    (0, helpers_1.assertIsBuffer)(privateKey);\n    // skip the type flag and use the X, Y points\n    return Buffer.from((0, secp256k1_1.publicKeyCreate)(privateKey, false)).slice(1);\n};\nexports.privateToPublic = privateToPublic;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nvar privateToAddress = function (privateKey) {\n    return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));\n};\nexports.privateToAddress = privateToAddress;\n/**\n * Converts a public key to the Ethereum format.\n */\nvar importPublic = function (publicKey) {\n    (0, helpers_1.assertIsBuffer)(publicKey);\n    if (publicKey.length !== 64) {\n        publicKey = Buffer.from((0, secp256k1_1.publicKeyConvert)(publicKey, false).slice(1));\n    }\n    return publicKey;\n};\nexports.importPublic = importPublic;\n/**\n * Returns the zero address.\n */\nvar zeroAddress = function () {\n    var addressLength = 20;\n    var addr = (0, bytes_1.zeros)(addressLength);\n    return (0, bytes_1.bufferToHex)(addr);\n};\nexports.zeroAddress = zeroAddress;\n/**\n * Checks if a given address is the zero address.\n */\nvar isZeroAddress = function (hexAddress) {\n    try {\n        (0, helpers_1.assertIsString)(hexAddress);\n    }\n    catch (e) {\n        return false;\n    }\n    var zeroAddr = (0, exports.zeroAddress)();\n    return zeroAddr === hexAddress;\n};\nexports.isZeroAddress = isZeroAddress;\n//# sourceMappingURL=account.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Address = void 0;\nvar assert_1 = __importDefault(require(\"assert\"));\nvar externals_1 = require(\"./externals\");\nvar bytes_1 = require(\"./bytes\");\nvar account_1 = require(\"./account\");\nvar Address = /** @class */ (function () {\n    function Address(buf) {\n        (0, assert_1.default)(buf.length === 20, 'Invalid address length');\n        this.buf = buf;\n    }\n    /**\n     * Returns the zero address.\n     */\n    Address.zero = function () {\n        return new Address((0, bytes_1.zeros)(20));\n    };\n    /**\n     * Returns an Address object from a hex-encoded string.\n     * @param str - Hex-encoded address\n     */\n    Address.fromString = function (str) {\n        (0, assert_1.default)((0, account_1.isValidAddress)(str), 'Invalid address');\n        return new Address((0, bytes_1.toBuffer)(str));\n    };\n    /**\n     * Returns an address for a given public key.\n     * @param pubKey The two points of an uncompressed key\n     */\n    Address.fromPublicKey = function (pubKey) {\n        (0, assert_1.default)(Buffer.isBuffer(pubKey), 'Public key should be Buffer');\n        var buf = (0, account_1.pubToAddress)(pubKey);\n        return new Address(buf);\n    };\n    /**\n     * Returns an address for a given private key.\n     * @param privateKey A private key must be 256 bits wide\n     */\n    Address.fromPrivateKey = function (privateKey) {\n        (0, assert_1.default)(Buffer.isBuffer(privateKey), 'Private key should be Buffer');\n        var buf = (0, account_1.privateToAddress)(privateKey);\n        return new Address(buf);\n    };\n    /**\n     * Generates an address for a newly created contract.\n     * @param from The address which is creating this new address\n     * @param nonce The nonce of the from account\n     */\n    Address.generate = function (from, nonce) {\n        (0, assert_1.default)(externals_1.BN.isBN(nonce));\n        return new Address((0, account_1.generateAddress)(from.buf, nonce.toArrayLike(Buffer)));\n    };\n    /**\n     * Generates an address for a contract created using CREATE2.\n     * @param from The address which is creating this new address\n     * @param salt A salt\n     * @param initCode The init code of the contract being created\n     */\n    Address.generate2 = function (from, salt, initCode) {\n        (0, assert_1.default)(Buffer.isBuffer(salt));\n        (0, assert_1.default)(Buffer.isBuffer(initCode));\n        return new Address((0, account_1.generateAddress2)(from.buf, salt, initCode));\n    };\n    /**\n     * Is address equal to another.\n     */\n    Address.prototype.equals = function (address) {\n        return this.buf.equals(address.buf);\n    };\n    /**\n     * Is address zero.\n     */\n    Address.prototype.isZero = function () {\n        return this.equals(Address.zero());\n    };\n    /**\n     * True if address is in the address range defined\n     * by EIP-1352\n     */\n    Address.prototype.isPrecompileOrSystemAddress = function () {\n        var addressBN = new externals_1.BN(this.buf);\n        var rangeMin = new externals_1.BN(0);\n        var rangeMax = new externals_1.BN('ffff', 'hex');\n        return addressBN.gte(rangeMin) && addressBN.lte(rangeMax);\n    };\n    /**\n     * Returns hex encoding of address.\n     */\n    Address.prototype.toString = function () {\n        return '0x' + this.buf.toString('hex');\n    };\n    /**\n     * Returns Buffer representation of address.\n     */\n    Address.prototype.toBuffer = function () {\n        return Buffer.from(this.buf);\n    };\n    return Address;\n}());\nexports.Address = Address;\n//# sourceMappingURL=address.js.map","\"use strict\";\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.bufArrToArr = exports.arrToBufArr = exports.validateNoLeadingZeroes = exports.baToJSON = exports.toUtf8 = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToHex = exports.bufferToInt = exports.toBuffer = exports.unpadHexString = exports.unpadArray = exports.unpadBuffer = exports.setLengthRight = exports.setLengthLeft = exports.zeros = exports.intToBuffer = exports.intToHex = void 0;\nvar externals_1 = require(\"./externals\");\nvar internal_1 = require(\"./internal\");\nvar helpers_1 = require(\"./helpers\");\n/**\n * Converts a `Number` into a hex `String`\n * @param {Number} i\n * @return {String}\n */\nvar intToHex = function (i) {\n    if (!Number.isSafeInteger(i) || i < 0) {\n        throw new Error(\"Received an invalid integer type: \".concat(i));\n    }\n    return \"0x\".concat(i.toString(16));\n};\nexports.intToHex = intToHex;\n/**\n * Converts an `Number` to a `Buffer`\n * @param {Number} i\n * @return {Buffer}\n */\nvar intToBuffer = function (i) {\n    var hex = (0, exports.intToHex)(i);\n    return Buffer.from((0, internal_1.padToEven)(hex.slice(2)), 'hex');\n};\nexports.intToBuffer = intToBuffer;\n/**\n * Returns a buffer filled with 0s.\n * @param bytes the number of bytes the buffer should be\n */\nvar zeros = function (bytes) {\n    return Buffer.allocUnsafe(bytes).fill(0);\n};\nexports.zeros = zeros;\n/**\n * Pads a `Buffer` with zeros till it has `length` bytes.\n * Truncates the beginning or end of input if its length exceeds `length`.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @param right whether to start padding form the left or right\n * @return (Buffer)\n */\nvar setLength = function (msg, length, right) {\n    var buf = (0, exports.zeros)(length);\n    if (right) {\n        if (msg.length < length) {\n            msg.copy(buf);\n            return buf;\n        }\n        return msg.slice(0, length);\n    }\n    else {\n        if (msg.length < length) {\n            msg.copy(buf, length - msg.length);\n            return buf;\n        }\n        return msg.slice(-length);\n    }\n};\n/**\n * Left Pads a `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @return (Buffer)\n */\nvar setLengthLeft = function (msg, length) {\n    (0, helpers_1.assertIsBuffer)(msg);\n    return setLength(msg, length, false);\n};\nexports.setLengthLeft = setLengthLeft;\n/**\n * Right Pads a `Buffer` with trailing zeros till it has `length` bytes.\n * it truncates the end if it exceeds.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @return (Buffer)\n */\nvar setLengthRight = function (msg, length) {\n    (0, helpers_1.assertIsBuffer)(msg);\n    return setLength(msg, length, true);\n};\nexports.setLengthRight = setLengthRight;\n/**\n * Trims leading zeros from a `Buffer`, `String` or `Number[]`.\n * @param a (Buffer|Array|String)\n * @return (Buffer|Array|String)\n */\nvar stripZeros = function (a) {\n    var first = a[0];\n    while (a.length > 0 && first.toString() === '0') {\n        a = a.slice(1);\n        first = a[0];\n    }\n    return a;\n};\n/**\n * Trims leading zeros from a `Buffer`.\n * @param a (Buffer)\n * @return (Buffer)\n */\nvar unpadBuffer = function (a) {\n    (0, helpers_1.assertIsBuffer)(a);\n    return stripZeros(a);\n};\nexports.unpadBuffer = unpadBuffer;\n/**\n * Trims leading zeros from an `Array` (of numbers).\n * @param a (number[])\n * @return (number[])\n */\nvar unpadArray = function (a) {\n    (0, helpers_1.assertIsArray)(a);\n    return stripZeros(a);\n};\nexports.unpadArray = unpadArray;\n/**\n * Trims leading zeros from a hex-prefixed `String`.\n * @param a (String)\n * @return (String)\n */\nvar unpadHexString = function (a) {\n    (0, helpers_1.assertIsHexString)(a);\n    a = (0, internal_1.stripHexPrefix)(a);\n    return stripZeros(a);\n};\nexports.unpadHexString = unpadHexString;\n/**\n * Attempts to turn a value into a `Buffer`.\n * Inputs supported: `Buffer`, `String` (hex-prefixed), `Number`, null/undefined, `BN` and other objects\n * with a `toArray()` or `toBuffer()` method.\n * @param v the value\n */\nvar toBuffer = function (v) {\n    if (v === null || v === undefined) {\n        return Buffer.allocUnsafe(0);\n    }\n    if (Buffer.isBuffer(v)) {\n        return Buffer.from(v);\n    }\n    if (Array.isArray(v) || v instanceof Uint8Array) {\n        return Buffer.from(v);\n    }\n    if (typeof v === 'string') {\n        if (!(0, internal_1.isHexString)(v)) {\n            throw new Error(\"Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: \".concat(v));\n        }\n        return Buffer.from((0, internal_1.padToEven)((0, internal_1.stripHexPrefix)(v)), 'hex');\n    }\n    if (typeof v === 'number') {\n        return (0, exports.intToBuffer)(v);\n    }\n    if (externals_1.BN.isBN(v)) {\n        if (v.isNeg()) {\n            throw new Error(\"Cannot convert negative BN to buffer. Given: \".concat(v));\n        }\n        return v.toArrayLike(Buffer);\n    }\n    if (v.toArray) {\n        // converts a BN to a Buffer\n        return Buffer.from(v.toArray());\n    }\n    if (v.toBuffer) {\n        return Buffer.from(v.toBuffer());\n    }\n    throw new Error('invalid type');\n};\nexports.toBuffer = toBuffer;\n/**\n * Converts a `Buffer` to a `Number`.\n * @param buf `Buffer` object to convert\n * @throws If the input number exceeds 53 bits.\n */\nvar bufferToInt = function (buf) {\n    return new externals_1.BN((0, exports.toBuffer)(buf)).toNumber();\n};\nexports.bufferToInt = bufferToInt;\n/**\n * Converts a `Buffer` into a `0x`-prefixed hex `String`.\n * @param buf `Buffer` object to convert\n */\nvar bufferToHex = function (buf) {\n    buf = (0, exports.toBuffer)(buf);\n    return '0x' + buf.toString('hex');\n};\nexports.bufferToHex = bufferToHex;\n/**\n * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.\n * @param num Signed integer value\n */\nvar fromSigned = function (num) {\n    return new externals_1.BN(num).fromTwos(256);\n};\nexports.fromSigned = fromSigned;\n/**\n * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.\n * @param num\n */\nvar toUnsigned = function (num) {\n    return Buffer.from(num.toTwos(256).toArray());\n};\nexports.toUnsigned = toUnsigned;\n/**\n * Adds \"0x\" to a given `String` if it does not already start with \"0x\".\n */\nvar addHexPrefix = function (str) {\n    if (typeof str !== 'string') {\n        return str;\n    }\n    return (0, internal_1.isHexPrefixed)(str) ? str : '0x' + str;\n};\nexports.addHexPrefix = addHexPrefix;\n/**\n * Returns the utf8 string representation from a hex string.\n *\n * Examples:\n *\n * Input 1: '657468657265756d000000000000000000000000000000000000000000000000'\n * Input 2: '657468657265756d'\n * Input 3: '000000000000000000000000000000000000000000000000657468657265756d'\n *\n * Output (all 3 input variants): 'ethereum'\n *\n * Note that this method is not intended to be used with hex strings\n * representing quantities in both big endian or little endian notation.\n *\n * @param string Hex string, should be `0x` prefixed\n * @return Utf8 string\n */\nvar toUtf8 = function (hex) {\n    var zerosRegexp = /^(00)+|(00)+$/g;\n    hex = (0, internal_1.stripHexPrefix)(hex);\n    if (hex.length % 2 !== 0) {\n        throw new Error('Invalid non-even hex string input for toUtf8() provided');\n    }\n    var bufferVal = Buffer.from(hex.replace(zerosRegexp, ''), 'hex');\n    return bufferVal.toString('utf8');\n};\nexports.toUtf8 = toUtf8;\n/**\n * Converts a `Buffer` or `Array` to JSON.\n * @param ba (Buffer|Array)\n * @return (Array|String|null)\n */\nvar baToJSON = function (ba) {\n    if (Buffer.isBuffer(ba)) {\n        return \"0x\".concat(ba.toString('hex'));\n    }\n    else if (ba instanceof Array) {\n        var array = [];\n        for (var i = 0; i < ba.length; i++) {\n            array.push((0, exports.baToJSON)(ba[i]));\n        }\n        return array;\n    }\n};\nexports.baToJSON = baToJSON;\n/**\n * Checks provided Buffers for leading zeroes and throws if found.\n *\n * Examples:\n *\n * Valid values: 0x1, 0x, 0x01, 0x1234\n * Invalid values: 0x0, 0x00, 0x001, 0x0001\n *\n * Note: This method is useful for validating that RLP encoded integers comply with the rule that all\n * integer values encoded to RLP must be in the most compact form and contain no leading zero bytes\n * @param values An object containing string keys and Buffer values\n * @throws if any provided value is found to have leading zero bytes\n */\nvar validateNoLeadingZeroes = function (values) {\n    var e_1, _a;\n    try {\n        for (var _b = __values(Object.entries(values)), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var _d = __read(_c.value, 2), k = _d[0], v = _d[1];\n            if (v !== undefined && v.length > 0 && v[0] === 0) {\n                throw new Error(\"\".concat(k, \" cannot have leading zeroes, received: \").concat(v.toString('hex')));\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n};\nexports.validateNoLeadingZeroes = validateNoLeadingZeroes;\nfunction arrToBufArr(arr) {\n    if (!Array.isArray(arr)) {\n        return Buffer.from(arr);\n    }\n    return arr.map(function (a) { return arrToBufArr(a); });\n}\nexports.arrToBufArr = arrToBufArr;\nfunction bufArrToArr(arr) {\n    if (!Array.isArray(arr)) {\n        return Uint8Array.from(arr !== null && arr !== void 0 ? arr : []);\n    }\n    return arr.map(function (a) { return bufArrToArr(a); });\n}\nexports.bufArrToArr = bufArrToArr;\n//# sourceMappingURL=bytes.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.MAX_INTEGER = exports.MAX_UINT64 = void 0;\nvar buffer_1 = require(\"buffer\");\nvar externals_1 = require(\"./externals\");\n/**\n * 2^64-1\n */\nexports.MAX_UINT64 = new externals_1.BN('ffffffffffffffff', 16);\n/**\n * The max integer that the evm can handle (2^256-1)\n */\nexports.MAX_INTEGER = new externals_1.BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);\n/**\n * 2^256\n */\nexports.TWO_POW256 = new externals_1.BN('10000000000000000000000000000000000000000000000000000000000000000', 16);\n/**\n * Keccak-256 hash of null\n */\nexports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';\n/**\n * Keccak-256 hash of null\n */\nexports.KECCAK256_NULL = buffer_1.Buffer.from(exports.KECCAK256_NULL_S, 'hex');\n/**\n * Keccak-256 of an RLP of an empty array\n */\nexports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';\n/**\n * Keccak-256 of an RLP of an empty array\n */\nexports.KECCAK256_RLP_ARRAY = buffer_1.Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');\n/**\n * Keccak-256 hash of the RLP of null\n */\nexports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';\n/**\n * Keccak-256 hash of the RLP of null\n */\nexports.KECCAK256_RLP = buffer_1.Buffer.from(exports.KECCAK256_RLP_S, 'hex');\n//# sourceMappingURL=constants.js.map","\"use strict\";\n/**\n * Re-exports commonly used modules:\n * * Exports [`BN`](https://github.com/indutny/bn.js), [`rlp`](https://github.com/ethereumjs/rlp).\n * @packageDocumentation\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.rlp = exports.BN = void 0;\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\nexports.BN = bn_js_1.default;\nvar rlp = __importStar(require(\"rlp\"));\nexports.rlp = rlp;\n//# sourceMappingURL=externals.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.rlphash = exports.ripemd160FromArray = exports.ripemd160FromString = exports.ripemd160 = exports.sha256FromArray = exports.sha256FromString = exports.sha256 = exports.keccakFromArray = exports.keccakFromHexString = exports.keccakFromString = exports.keccak256 = exports.keccak = void 0;\nvar keccak_1 = require(\"ethereum-cryptography/keccak\");\nvar createHash = require('create-hash');\nvar externals_1 = require(\"./externals\");\nvar bytes_1 = require(\"./bytes\");\nvar helpers_1 = require(\"./helpers\");\n/**\n * Creates Keccak hash of a Buffer input\n * @param a The input data (Buffer)\n * @param bits (number = 256) The Keccak width\n */\nvar keccak = function (a, bits) {\n    if (bits === void 0) { bits = 256; }\n    (0, helpers_1.assertIsBuffer)(a);\n    switch (bits) {\n        case 224: {\n            return (0, keccak_1.keccak224)(a);\n        }\n        case 256: {\n            return (0, keccak_1.keccak256)(a);\n        }\n        case 384: {\n            return (0, keccak_1.keccak384)(a);\n        }\n        case 512: {\n            return (0, keccak_1.keccak512)(a);\n        }\n        default: {\n            throw new Error(\"Invald algorithm: keccak\".concat(bits));\n        }\n    }\n};\nexports.keccak = keccak;\n/**\n * Creates Keccak-256 hash of the input, alias for keccak(a, 256).\n * @param a The input data (Buffer)\n */\nvar keccak256 = function (a) {\n    return (0, exports.keccak)(a);\n};\nexports.keccak256 = keccak256;\n/**\n * Creates Keccak hash of a utf-8 string input\n * @param a The input data (String)\n * @param bits (number = 256) The Keccak width\n */\nvar keccakFromString = function (a, bits) {\n    if (bits === void 0) { bits = 256; }\n    (0, helpers_1.assertIsString)(a);\n    var buf = Buffer.from(a, 'utf8');\n    return (0, exports.keccak)(buf, bits);\n};\nexports.keccakFromString = keccakFromString;\n/**\n * Creates Keccak hash of an 0x-prefixed string input\n * @param a The input data (String)\n * @param bits (number = 256) The Keccak width\n */\nvar keccakFromHexString = function (a, bits) {\n    if (bits === void 0) { bits = 256; }\n    (0, helpers_1.assertIsHexString)(a);\n    return (0, exports.keccak)((0, bytes_1.toBuffer)(a), bits);\n};\nexports.keccakFromHexString = keccakFromHexString;\n/**\n * Creates Keccak hash of a number array input\n * @param a The input data (number[])\n * @param bits (number = 256) The Keccak width\n */\nvar keccakFromArray = function (a, bits) {\n    if (bits === void 0) { bits = 256; }\n    (0, helpers_1.assertIsArray)(a);\n    return (0, exports.keccak)((0, bytes_1.toBuffer)(a), bits);\n};\nexports.keccakFromArray = keccakFromArray;\n/**\n * Creates SHA256 hash of an input.\n * @param  a The input data (Buffer|Array|String)\n */\nvar _sha256 = function (a) {\n    a = (0, bytes_1.toBuffer)(a);\n    return createHash('sha256').update(a).digest();\n};\n/**\n * Creates SHA256 hash of a Buffer input.\n * @param a The input data (Buffer)\n */\nvar sha256 = function (a) {\n    (0, helpers_1.assertIsBuffer)(a);\n    return _sha256(a);\n};\nexports.sha256 = sha256;\n/**\n * Creates SHA256 hash of a string input.\n * @param a The input data (string)\n */\nvar sha256FromString = function (a) {\n    (0, helpers_1.assertIsString)(a);\n    return _sha256(a);\n};\nexports.sha256FromString = sha256FromString;\n/**\n * Creates SHA256 hash of a number[] input.\n * @param a The input data (number[])\n */\nvar sha256FromArray = function (a) {\n    (0, helpers_1.assertIsArray)(a);\n    return _sha256(a);\n};\nexports.sha256FromArray = sha256FromArray;\n/**\n * Creates RIPEMD160 hash of the input.\n * @param a The input data (Buffer|Array|String|Number)\n * @param padded Whether it should be padded to 256 bits or not\n */\nvar _ripemd160 = function (a, padded) {\n    a = (0, bytes_1.toBuffer)(a);\n    var hash = createHash('rmd160').update(a).digest();\n    if (padded === true) {\n        return (0, bytes_1.setLengthLeft)(hash, 32);\n    }\n    else {\n        return hash;\n    }\n};\n/**\n * Creates RIPEMD160 hash of a Buffer input.\n * @param a The input data (Buffer)\n * @param padded Whether it should be padded to 256 bits or not\n */\nvar ripemd160 = function (a, padded) {\n    (0, helpers_1.assertIsBuffer)(a);\n    return _ripemd160(a, padded);\n};\nexports.ripemd160 = ripemd160;\n/**\n * Creates RIPEMD160 hash of a string input.\n * @param a The input data (String)\n * @param padded Whether it should be padded to 256 bits or not\n */\nvar ripemd160FromString = function (a, padded) {\n    (0, helpers_1.assertIsString)(a);\n    return _ripemd160(a, padded);\n};\nexports.ripemd160FromString = ripemd160FromString;\n/**\n * Creates RIPEMD160 hash of a number[] input.\n * @param a The input data (number[])\n * @param padded Whether it should be padded to 256 bits or not\n */\nvar ripemd160FromArray = function (a, padded) {\n    (0, helpers_1.assertIsArray)(a);\n    return _ripemd160(a, padded);\n};\nexports.ripemd160FromArray = ripemd160FromArray;\n/**\n * Creates SHA-3 hash of the RLP encoded version of the input.\n * @param a The input data\n */\nvar rlphash = function (a) {\n    return (0, exports.keccak)(externals_1.rlp.encode(a));\n};\nexports.rlphash = rlphash;\n//# sourceMappingURL=hash.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assertIsString = exports.assertIsArray = exports.assertIsBuffer = exports.assertIsHexString = void 0;\nvar internal_1 = require(\"./internal\");\n/**\n * Throws if a string is not hex prefixed\n * @param {string} input string to check hex prefix of\n */\nvar assertIsHexString = function (input) {\n    if (!(0, internal_1.isHexString)(input)) {\n        var msg = \"This method only supports 0x-prefixed hex strings but input was: \".concat(input);\n        throw new Error(msg);\n    }\n};\nexports.assertIsHexString = assertIsHexString;\n/**\n * Throws if input is not a buffer\n * @param {Buffer} input value to check\n */\nvar assertIsBuffer = function (input) {\n    if (!Buffer.isBuffer(input)) {\n        var msg = \"This method only supports Buffer but input was: \".concat(input);\n        throw new Error(msg);\n    }\n};\nexports.assertIsBuffer = assertIsBuffer;\n/**\n * Throws if input is not an array\n * @param {number[]} input value to check\n */\nvar assertIsArray = function (input) {\n    if (!Array.isArray(input)) {\n        var msg = \"This method only supports number arrays but input was: \".concat(input);\n        throw new Error(msg);\n    }\n};\nexports.assertIsArray = assertIsArray;\n/**\n * Throws if input is not a string\n * @param {string} input value to check\n */\nvar assertIsString = function (input) {\n    if (typeof input !== 'string') {\n        var msg = \"This method only supports strings but input was: \".concat(input);\n        throw new Error(msg);\n    }\n};\nexports.assertIsString = assertIsString;\n//# sourceMappingURL=helpers.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isHexString = exports.getKeys = exports.fromAscii = exports.fromUtf8 = exports.toAscii = exports.arrayContainsArray = exports.getBinarySize = exports.padToEven = exports.stripHexPrefix = exports.isHexPrefixed = void 0;\n/**\n * Constants\n */\n__exportStar(require(\"./constants\"), exports);\n/**\n * Account class and helper functions\n */\n__exportStar(require(\"./account\"), exports);\n/**\n * Address type\n */\n__exportStar(require(\"./address\"), exports);\n/**\n * Hash functions\n */\n__exportStar(require(\"./hash\"), exports);\n/**\n * ECDSA signature\n */\n__exportStar(require(\"./signature\"), exports);\n/**\n * Utilities for manipulating Buffers, byte arrays, etc.\n */\n__exportStar(require(\"./bytes\"), exports);\n/**\n * Function for definining properties on an object\n */\n__exportStar(require(\"./object\"), exports);\n/**\n * External exports (BN, rlp)\n */\n__exportStar(require(\"./externals\"), exports);\n/**\n * Helpful TypeScript types\n */\n__exportStar(require(\"./types\"), exports);\n/**\n * Export ethjs-util methods\n */\nvar internal_1 = require(\"./internal\");\nObject.defineProperty(exports, \"isHexPrefixed\", { enumerable: true, get: function () { return internal_1.isHexPrefixed; } });\nObject.defineProperty(exports, \"stripHexPrefix\", { enumerable: true, get: function () { return internal_1.stripHexPrefix; } });\nObject.defineProperty(exports, \"padToEven\", { enumerable: true, get: function () { return internal_1.padToEven; } });\nObject.defineProperty(exports, \"getBinarySize\", { enumerable: true, get: function () { return internal_1.getBinarySize; } });\nObject.defineProperty(exports, \"arrayContainsArray\", { enumerable: true, get: function () { return internal_1.arrayContainsArray; } });\nObject.defineProperty(exports, \"toAscii\", { enumerable: true, get: function () { return internal_1.toAscii; } });\nObject.defineProperty(exports, \"fromUtf8\", { enumerable: true, get: function () { return internal_1.fromUtf8; } });\nObject.defineProperty(exports, \"fromAscii\", { enumerable: true, get: function () { return internal_1.fromAscii; } });\nObject.defineProperty(exports, \"getKeys\", { enumerable: true, get: function () { return internal_1.getKeys; } });\nObject.defineProperty(exports, \"isHexString\", { enumerable: true, get: function () { return internal_1.isHexString; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\n/*\nThe MIT License\n\nCopyright (c) 2016 Nick Dodson. nickdodson.com\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isHexString = exports.getKeys = exports.fromAscii = exports.fromUtf8 = exports.toAscii = exports.arrayContainsArray = exports.getBinarySize = exports.padToEven = exports.stripHexPrefix = exports.isHexPrefixed = void 0;\n/**\n * Returns a `Boolean` on whether or not the a `String` starts with '0x'\n * @param str the string input value\n * @return a boolean if it is or is not hex prefixed\n * @throws if the str input is not a string\n */\nfunction isHexPrefixed(str) {\n    if (typeof str !== 'string') {\n        throw new Error(\"[isHexPrefixed] input must be type 'string', received type \".concat(typeof str));\n    }\n    return str[0] === '0' && str[1] === 'x';\n}\nexports.isHexPrefixed = isHexPrefixed;\n/**\n * Removes '0x' from a given `String` if present\n * @param str the string value\n * @returns the string without 0x prefix\n */\nvar stripHexPrefix = function (str) {\n    if (typeof str !== 'string')\n        throw new Error(\"[stripHexPrefix] input must be type 'string', received \".concat(typeof str));\n    return isHexPrefixed(str) ? str.slice(2) : str;\n};\nexports.stripHexPrefix = stripHexPrefix;\n/**\n * Pads a `String` to have an even length\n * @param value\n * @return output\n */\nfunction padToEven(value) {\n    var a = value;\n    if (typeof a !== 'string') {\n        throw new Error(\"[padToEven] value must be type 'string', received \".concat(typeof a));\n    }\n    if (a.length % 2)\n        a = \"0\".concat(a);\n    return a;\n}\nexports.padToEven = padToEven;\n/**\n * Get the binary size of a string\n * @param str\n * @returns the number of bytes contained within the string\n */\nfunction getBinarySize(str) {\n    if (typeof str !== 'string') {\n        throw new Error(\"[getBinarySize] method requires input type 'string', recieved \".concat(typeof str));\n    }\n    return Buffer.byteLength(str, 'utf8');\n}\nexports.getBinarySize = getBinarySize;\n/**\n * Returns TRUE if the first specified array contains all elements\n * from the second one. FALSE otherwise.\n *\n * @param superset\n * @param subset\n *\n */\nfunction arrayContainsArray(superset, subset, some) {\n    if (Array.isArray(superset) !== true) {\n        throw new Error(\"[arrayContainsArray] method requires input 'superset' to be an array, got type '\".concat(typeof superset, \"'\"));\n    }\n    if (Array.isArray(subset) !== true) {\n        throw new Error(\"[arrayContainsArray] method requires input 'subset' to be an array, got type '\".concat(typeof subset, \"'\"));\n    }\n    return subset[some ? 'some' : 'every'](function (value) { return superset.indexOf(value) >= 0; });\n}\nexports.arrayContainsArray = arrayContainsArray;\n/**\n * Should be called to get ascii from its hex representation\n *\n * @param string in hex\n * @returns ascii string representation of hex value\n */\nfunction toAscii(hex) {\n    var str = '';\n    var i = 0;\n    var l = hex.length;\n    if (hex.substring(0, 2) === '0x')\n        i = 2;\n    for (; i < l; i += 2) {\n        var code = parseInt(hex.substr(i, 2), 16);\n        str += String.fromCharCode(code);\n    }\n    return str;\n}\nexports.toAscii = toAscii;\n/**\n * Should be called to get hex representation (prefixed by 0x) of utf8 string\n *\n * @param string\n * @param optional padding\n * @returns hex representation of input string\n */\nfunction fromUtf8(stringValue) {\n    var str = Buffer.from(stringValue, 'utf8');\n    return \"0x\".concat(padToEven(str.toString('hex')).replace(/^0+|0+$/g, ''));\n}\nexports.fromUtf8 = fromUtf8;\n/**\n * Should be called to get hex representation (prefixed by 0x) of ascii string\n *\n * @param  string\n * @param  optional padding\n * @returns  hex representation of input string\n */\nfunction fromAscii(stringValue) {\n    var hex = '';\n    for (var i = 0; i < stringValue.length; i++) {\n        var code = stringValue.charCodeAt(i);\n        var n = code.toString(16);\n        hex += n.length < 2 ? \"0\".concat(n) : n;\n    }\n    return \"0x\".concat(hex);\n}\nexports.fromAscii = fromAscii;\n/**\n * Returns the keys from an array of objects.\n * @example\n * ```js\n * getKeys([{a: '1', b: '2'}, {a: '3', b: '4'}], 'a') => ['1', '3']\n *````\n * @param  params\n * @param  key\n * @param  allowEmpty\n * @returns output just a simple array of output keys\n */\nfunction getKeys(params, key, allowEmpty) {\n    if (!Array.isArray(params)) {\n        throw new Error(\"[getKeys] method expects input 'params' to be an array, got \".concat(typeof params));\n    }\n    if (typeof key !== 'string') {\n        throw new Error(\"[getKeys] method expects input 'key' to be type 'string', got \".concat(typeof params));\n    }\n    var result = [];\n    for (var i = 0; i < params.length; i++) {\n        var value = params[i][key];\n        if (allowEmpty && !value) {\n            value = '';\n        }\n        else if (typeof value !== 'string') {\n            throw new Error(\"invalid abi - expected type 'string', received \".concat(typeof value));\n        }\n        result.push(value);\n    }\n    return result;\n}\nexports.getKeys = getKeys;\n/**\n * Is the string a hex string.\n *\n * @param  value\n * @param  length\n * @returns  output the string is a hex string\n */\nfunction isHexString(value, length) {\n    if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/))\n        return false;\n    if (length && value.length !== 2 + 2 * length)\n        return false;\n    return true;\n}\nexports.isHexString = isHexString;\n//# sourceMappingURL=internal.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defineProperties = void 0;\nvar assert_1 = __importDefault(require(\"assert\"));\nvar internal_1 = require(\"./internal\");\nvar externals_1 = require(\"./externals\");\nvar bytes_1 = require(\"./bytes\");\n/**\n * Defines properties on a `Object`. It make the assumption that underlying data is binary.\n * @param self the `Object` to define properties on\n * @param fields an array fields to define. Fields can contain:\n * * `name` - the name of the properties\n * * `length` - the number of bytes the field can have\n * * `allowLess` - if the field can be less than the length\n * * `allowEmpty`\n * @param data data to be validated against the definitions\n * @deprecated\n */\nvar defineProperties = function (self, fields, data) {\n    self.raw = [];\n    self._fields = [];\n    // attach the `toJSON`\n    self.toJSON = function (label) {\n        if (label === void 0) { label = false; }\n        if (label) {\n            var obj_1 = {};\n            self._fields.forEach(function (field) {\n                obj_1[field] = \"0x\".concat(self[field].toString('hex'));\n            });\n            return obj_1;\n        }\n        return (0, bytes_1.baToJSON)(self.raw);\n    };\n    self.serialize = function serialize() {\n        return externals_1.rlp.encode(self.raw);\n    };\n    fields.forEach(function (field, i) {\n        self._fields.push(field.name);\n        function getter() {\n            return self.raw[i];\n        }\n        function setter(v) {\n            v = (0, bytes_1.toBuffer)(v);\n            if (v.toString('hex') === '00' && !field.allowZero) {\n                v = Buffer.allocUnsafe(0);\n            }\n            if (field.allowLess && field.length) {\n                v = (0, bytes_1.unpadBuffer)(v);\n                (0, assert_1.default)(field.length >= v.length, \"The field \".concat(field.name, \" must not have more \").concat(field.length, \" bytes\"));\n            }\n            else if (!(field.allowZero && v.length === 0) && field.length) {\n                (0, assert_1.default)(field.length === v.length, \"The field \".concat(field.name, \" must have byte length of \").concat(field.length));\n            }\n            self.raw[i] = v;\n        }\n        Object.defineProperty(self, field.name, {\n            enumerable: true,\n            configurable: true,\n            get: getter,\n            set: setter,\n        });\n        if (field.default) {\n            self[field.name] = field.default;\n        }\n        // attach alias\n        if (field.alias) {\n            Object.defineProperty(self, field.alias, {\n                enumerable: false,\n                configurable: true,\n                set: setter,\n                get: getter,\n            });\n        }\n    });\n    // if the constuctor is passed data\n    if (data) {\n        if (typeof data === 'string') {\n            data = Buffer.from((0, internal_1.stripHexPrefix)(data), 'hex');\n        }\n        if (Buffer.isBuffer(data)) {\n            data = externals_1.rlp.decode(data);\n        }\n        if (Array.isArray(data)) {\n            if (data.length > self._fields.length) {\n                throw new Error('wrong number of fields in data');\n            }\n            // make sure all the items are buffers\n            data.forEach(function (d, i) {\n                self[self._fields[i]] = (0, bytes_1.toBuffer)(d);\n            });\n        }\n        else if (typeof data === 'object') {\n            var keys_1 = Object.keys(data);\n            fields.forEach(function (field) {\n                if (keys_1.indexOf(field.name) !== -1)\n                    self[field.name] = data[field.name];\n                if (keys_1.indexOf(field.alias) !== -1)\n                    self[field.alias] = data[field.alias];\n            });\n        }\n        else {\n            throw new Error('invalid data');\n        }\n    }\n};\nexports.defineProperties = defineProperties;\n//# sourceMappingURL=object.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toCompactSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;\nvar secp256k1_1 = require(\"ethereum-cryptography/secp256k1\");\nvar externals_1 = require(\"./externals\");\nvar bytes_1 = require(\"./bytes\");\nvar hash_1 = require(\"./hash\");\nvar helpers_1 = require(\"./helpers\");\nvar types_1 = require(\"./types\");\nfunction ecsign(msgHash, privateKey, chainId) {\n    var _a = (0, secp256k1_1.ecdsaSign)(msgHash, privateKey), signature = _a.signature, recovery = _a.recid;\n    var r = Buffer.from(signature.slice(0, 32));\n    var s = Buffer.from(signature.slice(32, 64));\n    if (!chainId || typeof chainId === 'number') {\n        // return legacy type ECDSASignature (deprecated in favor of ECDSASignatureBuffer to handle large chainIds)\n        if (chainId && !Number.isSafeInteger(chainId)) {\n            throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)');\n        }\n        var v_1 = chainId ? recovery + (chainId * 2 + 35) : recovery + 27;\n        return { r: r, s: s, v: v_1 };\n    }\n    var chainIdBN = (0, types_1.toType)(chainId, types_1.TypeOutput.BN);\n    var v = chainIdBN.muln(2).addn(35).addn(recovery).toArrayLike(Buffer);\n    return { r: r, s: s, v: v };\n}\nexports.ecsign = ecsign;\nfunction calculateSigRecovery(v, chainId) {\n    var vBN = (0, types_1.toType)(v, types_1.TypeOutput.BN);\n    if (!chainId) {\n        return vBN.subn(27);\n    }\n    var chainIdBN = (0, types_1.toType)(chainId, types_1.TypeOutput.BN);\n    return vBN.sub(chainIdBN.muln(2).addn(35));\n}\nfunction isValidSigRecovery(recovery) {\n    var rec = new externals_1.BN(recovery);\n    return rec.eqn(0) || rec.eqn(1);\n}\n/**\n * ECDSA public key recovery from signature.\n * @returns Recovered public key\n */\nvar ecrecover = function (msgHash, v, r, s, chainId) {\n    var signature = Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(s, 32)], 64);\n    var recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error('Invalid signature v value');\n    }\n    var senderPubKey = (0, secp256k1_1.ecdsaRecover)(signature, recovery.toNumber(), msgHash);\n    return Buffer.from((0, secp256k1_1.publicKeyConvert)(senderPubKey, false).slice(1));\n};\nexports.ecrecover = ecrecover;\n/**\n * Convert signature parameters into the format of `eth_sign` RPC method.\n * @returns Signature\n */\nvar toRpcSig = function (v, r, s, chainId) {\n    var recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error('Invalid signature v value');\n    }\n    // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin\n    return (0, bytes_1.bufferToHex)(Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(s, 32), (0, bytes_1.toBuffer)(v)]));\n};\nexports.toRpcSig = toRpcSig;\n/**\n * Convert signature parameters into the format of Compact Signature Representation (EIP-2098).\n * @returns Signature\n */\nvar toCompactSig = function (v, r, s, chainId) {\n    var recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error('Invalid signature v value');\n    }\n    var vn = (0, types_1.toType)(v, types_1.TypeOutput.Number);\n    var ss = s;\n    if ((vn > 28 && vn % 2 === 1) || vn === 1 || vn === 28) {\n        ss = Buffer.from(s);\n        ss[0] |= 0x80;\n    }\n    return (0, bytes_1.bufferToHex)(Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(ss, 32)]));\n};\nexports.toCompactSig = toCompactSig;\n/**\n * Convert signature format of the `eth_sign` RPC method to signature parameters\n * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053\n */\nvar fromRpcSig = function (sig) {\n    var buf = (0, bytes_1.toBuffer)(sig);\n    var r;\n    var s;\n    var v;\n    if (buf.length >= 65) {\n        r = buf.slice(0, 32);\n        s = buf.slice(32, 64);\n        v = (0, bytes_1.bufferToInt)(buf.slice(64));\n    }\n    else if (buf.length === 64) {\n        // Compact Signature Representation (https://eips.ethereum.org/EIPS/eip-2098)\n        r = buf.slice(0, 32);\n        s = buf.slice(32, 64);\n        v = (0, bytes_1.bufferToInt)(buf.slice(32, 33)) >> 7;\n        s[0] &= 0x7f;\n    }\n    else {\n        throw new Error('Invalid signature length');\n    }\n    // support both versions of `eth_sign` responses\n    if (v < 27) {\n        v += 27;\n    }\n    return {\n        v: v,\n        r: r,\n        s: s,\n    };\n};\nexports.fromRpcSig = fromRpcSig;\n/**\n * Validate a ECDSA signature.\n * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one\n */\nvar isValidSignature = function (v, r, s, homesteadOrLater, chainId) {\n    if (homesteadOrLater === void 0) { homesteadOrLater = true; }\n    var SECP256K1_N_DIV_2 = new externals_1.BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);\n    var SECP256K1_N = new externals_1.BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);\n    if (r.length !== 32 || s.length !== 32) {\n        return false;\n    }\n    if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {\n        return false;\n    }\n    var rBN = new externals_1.BN(r);\n    var sBN = new externals_1.BN(s);\n    if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {\n        return false;\n    }\n    if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {\n        return false;\n    }\n    return true;\n};\nexports.isValidSignature = isValidSignature;\n/**\n * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.\n * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`\n * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key\n * used to produce the signature.\n */\nvar hashPersonalMessage = function (message) {\n    (0, helpers_1.assertIsBuffer)(message);\n    var prefix = Buffer.from(\"\\u0019Ethereum Signed Message:\\n\".concat(message.length), 'utf-8');\n    return (0, hash_1.keccak)(Buffer.concat([prefix, message]));\n};\nexports.hashPersonalMessage = hashPersonalMessage;\n//# sourceMappingURL=signature.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toType = exports.TypeOutput = exports.bnToRlp = exports.bnToUnpaddedBuffer = exports.bnToHex = void 0;\nvar externals_1 = require(\"./externals\");\nvar internal_1 = require(\"./internal\");\nvar bytes_1 = require(\"./bytes\");\n/**\n * Convert BN to 0x-prefixed hex string.\n */\nfunction bnToHex(value) {\n    return \"0x\".concat(value.toString(16));\n}\nexports.bnToHex = bnToHex;\n/**\n * Convert value from BN to an unpadded Buffer\n * (useful for RLP transport)\n * @param value value to convert\n */\nfunction bnToUnpaddedBuffer(value) {\n    // Using `bn.toArrayLike(Buffer)` instead of `bn.toBuffer()`\n    // for compatibility with browserify and similar tools\n    return (0, bytes_1.unpadBuffer)(value.toArrayLike(Buffer));\n}\nexports.bnToUnpaddedBuffer = bnToUnpaddedBuffer;\n/**\n * Deprecated alias for {@link bnToUnpaddedBuffer}\n * @deprecated\n */\nfunction bnToRlp(value) {\n    return bnToUnpaddedBuffer(value);\n}\nexports.bnToRlp = bnToRlp;\n/**\n * Type output options\n */\nvar TypeOutput;\n(function (TypeOutput) {\n    TypeOutput[TypeOutput[\"Number\"] = 0] = \"Number\";\n    TypeOutput[TypeOutput[\"BN\"] = 1] = \"BN\";\n    TypeOutput[TypeOutput[\"Buffer\"] = 2] = \"Buffer\";\n    TypeOutput[TypeOutput[\"PrefixedHexString\"] = 3] = \"PrefixedHexString\";\n})(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));\nfunction toType(input, outputType) {\n    if (input === null) {\n        return null;\n    }\n    if (input === undefined) {\n        return undefined;\n    }\n    if (typeof input === 'string' && !(0, internal_1.isHexString)(input)) {\n        throw new Error(\"A string must be provided with a 0x-prefix, given: \".concat(input));\n    }\n    else if (typeof input === 'number' && !Number.isSafeInteger(input)) {\n        throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)');\n    }\n    var output = (0, bytes_1.toBuffer)(input);\n    if (outputType === TypeOutput.Buffer) {\n        return output;\n    }\n    else if (outputType === TypeOutput.BN) {\n        return new externals_1.BN(output);\n    }\n    else if (outputType === TypeOutput.Number) {\n        var bn = new externals_1.BN(output);\n        var max = new externals_1.BN(Number.MAX_SAFE_INTEGER.toString());\n        if (bn.gt(max)) {\n            throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)');\n        }\n        return bn.toNumber();\n    }\n    else {\n        // outputType === TypeOutput.PrefixedHexString\n        return \"0x\".concat(output.toString('hex'));\n    }\n}\nexports.toType = toType;\n//# sourceMappingURL=types.js.map"],"sourceRoot":""}