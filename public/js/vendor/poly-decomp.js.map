{"version":3,"sources":["webpack:///./node_modules/poly-decomp/src/index.js"],"names":["lineInt","l1","l2","precision","a1","b1","c1","a2","b2","c2","det","i","scalar_eq","lineSegmentsIntersect","p1","p2","q1","q2","dx","dy","da","db","s","t","triangleArea","a","b","c","isLeft","isLeftOn","isRight","isRightOn","module","exports","decomp","polygon","edges","polygonGetCutEdges","length","polygonSlice","quickDecomp","polygonQuickDecomp","result","reflexVertices","steinerPoints","delta","maxlevel","level","upperInt","lowerInt","p","upperDist","lowerDist","d","closestDist","upperIndex","lowerIndex","closestIndex","lowerPoly","upperPoly","poly","v","console","warn","polygonIsReflex","push","Number","MAX_VALUE","j","polygonAt","getIntersectionPoint","sqdist","polygonAppend","polygonCanSee2","isSimple","path","removeCollinearPoints","num","collinear","splice","removeDuplicatePoints","pi","points_eq","makeCCW","br","tmp","N","pop","polygonReverse","tmpPoint1","tmpPoint2","thresholdAngle","ab","bc","dot","magA","Math","sqrt","magB","acos","from","to","tmpLine1","tmpLine2","polygonCanSee","dist","polygonCopy","targetPoly","polygonClear","k","min","tmp1","tmp2","tmpPoly","nDiags","cutEdges","Array","polys","cutEdge","indexOf","abs"],"mappings":"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","file":"js/vendor/poly-decomp.js","sourcesContent":["module.exports = {\n    decomp: polygonDecomp,\n    quickDecomp: polygonQuickDecomp,\n    isSimple: polygonIsSimple,\n    removeCollinearPoints: polygonRemoveCollinearPoints,\n    removeDuplicatePoints: polygonRemoveDuplicatePoints,\n    makeCCW: polygonMakeCCW\n};\n\n/**\n * Compute the intersection between two lines.\n * @static\n * @method lineInt\n * @param  {Array}  l1          Line vector 1\n * @param  {Array}  l2          Line vector 2\n * @param  {Number} precision   Precision to use when checking if the lines are parallel\n * @return {Array}              The intersection point.\n */\nfunction lineInt(l1,l2,precision){\n    precision = precision || 0;\n    var i = [0,0]; // point\n    var a1, b1, c1, a2, b2, c2, det; // scalars\n    a1 = l1[1][1] - l1[0][1];\n    b1 = l1[0][0] - l1[1][0];\n    c1 = a1 * l1[0][0] + b1 * l1[0][1];\n    a2 = l2[1][1] - l2[0][1];\n    b2 = l2[0][0] - l2[1][0];\n    c2 = a2 * l2[0][0] + b2 * l2[0][1];\n    det = a1 * b2 - a2*b1;\n    if (!scalar_eq(det, 0, precision)) { // lines are not parallel\n        i[0] = (b2 * c1 - b1 * c2) / det;\n        i[1] = (a1 * c2 - a2 * c1) / det;\n    }\n    return i;\n}\n\n/**\n * Checks if two line segments intersects.\n * @method segmentsIntersect\n * @param {Array} p1 The start vertex of the first line segment.\n * @param {Array} p2 The end vertex of the first line segment.\n * @param {Array} q1 The start vertex of the second line segment.\n * @param {Array} q2 The end vertex of the second line segment.\n * @return {Boolean} True if the two line segments intersect\n */\nfunction lineSegmentsIntersect(p1, p2, q1, q2){\n\tvar dx = p2[0] - p1[0];\n\tvar dy = p2[1] - p1[1];\n\tvar da = q2[0] - q1[0];\n\tvar db = q2[1] - q1[1];\n\n\t// segments are parallel\n\tif((da*dy - db*dx) === 0){\n\t\treturn false;\n\t}\n\n\tvar s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);\n\tvar t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);\n\n\treturn (s>=0 && s<=1 && t>=0 && t<=1);\n}\n\n/**\n * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.\n * @static\n * @method area\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @return {Number}\n */\nfunction triangleArea(a,b,c){\n    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1])));\n}\n\nfunction isLeft(a,b,c){\n    return triangleArea(a,b,c) > 0;\n}\n\nfunction isLeftOn(a,b,c) {\n    return triangleArea(a, b, c) >= 0;\n}\n\nfunction isRight(a,b,c) {\n    return triangleArea(a, b, c) < 0;\n}\n\nfunction isRightOn(a,b,c) {\n    return triangleArea(a, b, c) <= 0;\n}\n\nvar tmpPoint1 = [],\n    tmpPoint2 = [];\n\n/**\n * Check if three points are collinear\n * @method collinear\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.\n * @return {Boolean}\n */\nfunction collinear(a,b,c,thresholdAngle) {\n    if(!thresholdAngle){\n        return triangleArea(a, b, c) === 0;\n    } else {\n        var ab = tmpPoint1,\n            bc = tmpPoint2;\n\n        ab[0] = b[0]-a[0];\n        ab[1] = b[1]-a[1];\n        bc[0] = c[0]-b[0];\n        bc[1] = c[1]-b[1];\n\n        var dot = ab[0]*bc[0] + ab[1]*bc[1],\n            magA = Math.sqrt(ab[0]*ab[0] + ab[1]*ab[1]),\n            magB = Math.sqrt(bc[0]*bc[0] + bc[1]*bc[1]),\n            angle = Math.acos(dot/(magA*magB));\n        return angle < thresholdAngle;\n    }\n}\n\nfunction sqdist(a,b){\n    var dx = b[0] - a[0];\n    var dy = b[1] - a[1];\n    return dx * dx + dy * dy;\n}\n\n/**\n * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.\n * @method at\n * @param  {Number} i\n * @return {Array}\n */\nfunction polygonAt(polygon, i){\n    var s = polygon.length;\n    return polygon[i < 0 ? i % s + s : i % s];\n}\n\n/**\n * Clear the polygon data\n * @method clear\n * @return {Array}\n */\nfunction polygonClear(polygon){\n    polygon.length = 0;\n}\n\n/**\n * Append points \"from\" to \"to\"-1 from an other polygon \"poly\" onto this one.\n * @method append\n * @param {Polygon} poly The polygon to get points from.\n * @param {Number}  from The vertex index in \"poly\".\n * @param {Number}  to The end vertex index in \"poly\". Note that this vertex is NOT included when appending.\n * @return {Array}\n */\nfunction polygonAppend(polygon, poly, from, to){\n    for(var i=from; i<to; i++){\n        polygon.push(poly[i]);\n    }\n}\n\n/**\n * Make sure that the polygon vertices are ordered counter-clockwise.\n * @method makeCCW\n */\nfunction polygonMakeCCW(polygon){\n    var br = 0,\n        v = polygon;\n\n    // find bottom right point\n    for (var i = 1; i < polygon.length; ++i) {\n        if (v[i][1] < v[br][1] || (v[i][1] === v[br][1] && v[i][0] > v[br][0])) {\n            br = i;\n        }\n    }\n\n    // reverse poly if clockwise\n    if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {\n        polygonReverse(polygon);\n        return true;\n    } else {\n        return false;\n    }\n}\n\n/**\n * Reverse the vertices in the polygon\n * @method reverse\n */\nfunction polygonReverse(polygon){\n    var tmp = [];\n    var N = polygon.length;\n    for(var i=0; i!==N; i++){\n        tmp.push(polygon.pop());\n    }\n    for(var i=0; i!==N; i++){\n\t\tpolygon[i] = tmp[i];\n    }\n}\n\n/**\n * Check if a point in the polygon is a reflex point\n * @method isReflex\n * @param  {Number}  i\n * @return {Boolean}\n */\nfunction polygonIsReflex(polygon, i){\n    return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));\n}\n\nvar tmpLine1=[],\n    tmpLine2=[];\n\n/**\n * Check if two vertices in the polygon can see each other\n * @method canSee\n * @param  {Number} a Vertex index 1\n * @param  {Number} b Vertex index 2\n * @return {Boolean}\n */\nfunction polygonCanSee(polygon, a,b) {\n    var p, dist, l1=tmpLine1, l2=tmpLine2;\n\n    if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {\n        return false;\n    }\n    dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));\n    for (var i = 0; i !== polygon.length; ++i) { // for each edge\n        if ((i + 1) % polygon.length === a || i === a){ // ignore incident edges\n            continue;\n        }\n        if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) { // if diag intersects an edge\n            l1[0] = polygonAt(polygon, a);\n            l1[1] = polygonAt(polygon, b);\n            l2[0] = polygonAt(polygon, i);\n            l2[1] = polygonAt(polygon, i + 1);\n            p = lineInt(l1,l2);\n            if (sqdist(polygonAt(polygon, a), p) < dist) { // if edge is blocking visibility to b\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n/**\n * Check if two vertices in the polygon can see each other\n * @method canSee2\n * @param  {Number} a Vertex index 1\n * @param  {Number} b Vertex index 2\n * @return {Boolean}\n */\nfunction polygonCanSee2(polygon, a,b) {\n    // for each edge\n    for (var i = 0; i !== polygon.length; ++i) {\n        // ignore incident edges\n        if (i === a || i === b || (i + 1) % polygon.length === a || (i + 1) % polygon.length === b){\n            continue;\n        }\n        if( lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i), polygonAt(polygon, i+1)) ){\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * Copy the polygon from vertex i to vertex j.\n * @method copy\n * @param  {Number} i\n * @param  {Number} j\n * @param  {Polygon} [targetPoly]   Optional target polygon to save in.\n * @return {Polygon}                The resulting copy.\n */\nfunction polygonCopy(polygon, i,j,targetPoly){\n    var p = targetPoly || [];\n    polygonClear(p);\n    if (i < j) {\n        // Insert all vertices from i to j\n        for(var k=i; k<=j; k++){\n            p.push(polygon[k]);\n        }\n\n    } else {\n\n        // Insert vertices 0 to j\n        for(var k=0; k<=j; k++){\n            p.push(polygon[k]);\n        }\n\n        // Insert vertices i to end\n        for(var k=i; k<polygon.length; k++){\n            p.push(polygon[k]);\n        }\n    }\n\n    return p;\n}\n\n/**\n * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.\n * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.\n * @method getCutEdges\n * @return {Array}\n */\nfunction polygonGetCutEdges(polygon) {\n    var min=[], tmp1=[], tmp2=[], tmpPoly = [];\n    var nDiags = Number.MAX_VALUE;\n\n    for (var i = 0; i < polygon.length; ++i) {\n        if (polygonIsReflex(polygon, i)) {\n            for (var j = 0; j < polygon.length; ++j) {\n                if (polygonCanSee(polygon, i, j)) {\n                    tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));\n                    tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));\n\n                    for(var k=0; k<tmp2.length; k++){\n                        tmp1.push(tmp2[k]);\n                    }\n\n                    if (tmp1.length < nDiags) {\n                        min = tmp1;\n                        nDiags = tmp1.length;\n                        min.push([polygonAt(polygon, i), polygonAt(polygon, j)]);\n                    }\n                }\n            }\n        }\n    }\n\n    return min;\n}\n\n/**\n * Decomposes the polygon into one or more convex sub-Polygons.\n * @method decomp\n * @return {Array} An array or Polygon objects.\n */\nfunction polygonDecomp(polygon){\n    var edges = polygonGetCutEdges(polygon);\n    if(edges.length > 0){\n        return polygonSlice(polygon, edges);\n    } else {\n        return [polygon];\n    }\n}\n\n/**\n * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.\n * @method slice\n * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()\n * @return {Array}\n */\nfunction polygonSlice(polygon, cutEdges){\n    if(cutEdges.length === 0){\n\t\treturn [polygon];\n    }\n    if(cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length===2 && cutEdges[0][0] instanceof Array){\n\n        var polys = [polygon];\n\n        for(var i=0; i<cutEdges.length; i++){\n            var cutEdge = cutEdges[i];\n            // Cut all polys\n            for(var j=0; j<polys.length; j++){\n                var poly = polys[j];\n                var result = polygonSlice(poly, cutEdge);\n                if(result){\n                    // Found poly! Cut and quit\n                    polys.splice(j,1);\n                    polys.push(result[0],result[1]);\n                    break;\n                }\n            }\n        }\n\n        return polys;\n    } else {\n\n        // Was given one edge\n        var cutEdge = cutEdges;\n        var i = polygon.indexOf(cutEdge[0]);\n        var j = polygon.indexOf(cutEdge[1]);\n\n        if(i !== -1 && j !== -1){\n            return [polygonCopy(polygon, i,j),\n                    polygonCopy(polygon, j,i)];\n        } else {\n            return false;\n        }\n    }\n}\n\n/**\n * Checks that the line segments of this polygon do not intersect each other.\n * @method isSimple\n * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]\n * @return {Boolean}\n * @todo Should it check all segments with all others?\n */\nfunction polygonIsSimple(polygon){\n    var path = polygon, i;\n    // Check\n    for(i=0; i<path.length-1; i++){\n        for(var j=0; j<i-1; j++){\n            if(lineSegmentsIntersect(path[i], path[i+1], path[j], path[j+1] )){\n                return false;\n            }\n        }\n    }\n\n    // Check the segment between the last and the first point to all others\n    for(i=1; i<path.length-2; i++){\n        if(lineSegmentsIntersect(path[0], path[path.length-1], path[i], path[i+1] )){\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction getIntersectionPoint(p1, p2, q1, q2, delta){\n\tdelta = delta || 0;\n\tvar a1 = p2[1] - p1[1];\n\tvar b1 = p1[0] - p2[0];\n\tvar c1 = (a1 * p1[0]) + (b1 * p1[1]);\n\tvar a2 = q2[1] - q1[1];\n\tvar b2 = q1[0] - q2[0];\n\tvar c2 = (a2 * q1[0]) + (b2 * q1[1]);\n\tvar det = (a1 * b2) - (a2 * b1);\n\n\tif(!scalar_eq(det,0,delta)){\n\t\treturn [((b2 * c1) - (b1 * c2)) / det, ((a1 * c2) - (a2 * c1)) / det];\n\t} else {\n\t\treturn [0,0];\n    }\n}\n\n/**\n * Quickly decompose the Polygon into convex sub-polygons.\n * @method quickDecomp\n * @param  {Array} result\n * @param  {Array} [reflexVertices]\n * @param  {Array} [steinerPoints]\n * @param  {Number} [delta]\n * @param  {Number} [maxlevel]\n * @param  {Number} [level]\n * @return {Array}\n */\nfunction polygonQuickDecomp(polygon, result,reflexVertices,steinerPoints,delta,maxlevel,level){\n    maxlevel = maxlevel || 100;\n    level = level || 0;\n    delta = delta || 25;\n    result = typeof(result)!==\"undefined\" ? result : [];\n    reflexVertices = reflexVertices || [];\n    steinerPoints = steinerPoints || [];\n\n    var upperInt=[0,0], lowerInt=[0,0], p=[0,0]; // Points\n    var upperDist=0, lowerDist=0, d=0, closestDist=0; // scalars\n    var upperIndex=0, lowerIndex=0, closestIndex=0; // Integers\n    var lowerPoly=[], upperPoly=[]; // polygons\n    var poly = polygon,\n        v = polygon;\n\n    if(v.length < 3){\n\t\treturn result;\n    }\n\n    level++;\n    if(level > maxlevel){\n        console.warn(\"quickDecomp: max level (\"+maxlevel+\") reached.\");\n        return result;\n    }\n\n    for (var i = 0; i < polygon.length; ++i) {\n        if (polygonIsReflex(poly, i)) {\n            reflexVertices.push(poly[i]);\n            upperDist = lowerDist = Number.MAX_VALUE;\n\n\n            for (var j = 0; j < polygon.length; ++j) {\n                if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) { // if line intersects with an edge\n                    p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1)); // find the point of intersection\n                    if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) { // make sure it's inside the poly\n                        d = sqdist(poly[i], p);\n                        if (d < lowerDist) { // keep only the closest intersection\n                            lowerDist = d;\n                            lowerInt = p;\n                            lowerIndex = j;\n                        }\n                    }\n                }\n                if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\n                    p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));\n                    if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {\n                        d = sqdist(poly[i], p);\n                        if (d < upperDist) {\n                            upperDist = d;\n                            upperInt = p;\n                            upperIndex = j;\n                        }\n                    }\n                }\n            }\n\n            // if there are no vertices to connect to, choose a point in the middle\n            if (lowerIndex === (upperIndex + 1) % polygon.length) {\n                //console.log(\"Case 1: Vertex(\"+i+\"), lowerIndex(\"+lowerIndex+\"), upperIndex(\"+upperIndex+\"), poly.size(\"+polygon.length+\")\");\n                p[0] = (lowerInt[0] + upperInt[0]) / 2;\n                p[1] = (lowerInt[1] + upperInt[1]) / 2;\n                steinerPoints.push(p);\n\n                if (i < upperIndex) {\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);\n                    polygonAppend(lowerPoly, poly, i, upperIndex+1);\n                    lowerPoly.push(p);\n                    upperPoly.push(p);\n                    if (lowerIndex !== 0){\n                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());\n                        polygonAppend(upperPoly, poly,lowerIndex,poly.length);\n                    }\n                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);\n                    polygonAppend(upperPoly, poly,0,i+1);\n                } else {\n                    if (i !== 0){\n                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());\n                        polygonAppend(lowerPoly, poly,i,poly.length);\n                    }\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);\n                    polygonAppend(lowerPoly, poly,0,upperIndex+1);\n                    lowerPoly.push(p);\n                    upperPoly.push(p);\n                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);\n                    polygonAppend(upperPoly, poly,lowerIndex,i+1);\n                }\n            } else {\n                // connect to the closest point within the triangle\n                //console.log(\"Case 2: Vertex(\"+i+\"), closestIndex(\"+closestIndex+\"), poly.size(\"+polygon.length+\")\\n\");\n\n                if (lowerIndex > upperIndex) {\n                    upperIndex += polygon.length;\n                }\n                closestDist = Number.MAX_VALUE;\n\n                if(upperIndex < lowerIndex){\n                    return result;\n                }\n\n                for (var j = lowerIndex; j <= upperIndex; ++j) {\n                    if (\n                        isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) &&\n                        isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))\n                    ) {\n                        d = sqdist(polygonAt(poly, i), polygonAt(poly, j));\n                        if (d < closestDist && polygonCanSee2(poly, i, j)) {\n                            closestDist = d;\n                            closestIndex = j % polygon.length;\n                        }\n                    }\n                }\n\n                if (i < closestIndex) {\n                    polygonAppend(lowerPoly, poly,i,closestIndex+1);\n                    if (closestIndex !== 0){\n                        polygonAppend(upperPoly, poly,closestIndex,v.length);\n                    }\n                    polygonAppend(upperPoly, poly,0,i+1);\n                } else {\n                    if (i !== 0){\n                        polygonAppend(lowerPoly, poly,i,v.length);\n                    }\n                    polygonAppend(lowerPoly, poly,0,closestIndex+1);\n                    polygonAppend(upperPoly, poly,closestIndex,i+1);\n                }\n            }\n\n            // solve smallest poly first\n            if (lowerPoly.length < upperPoly.length) {\n                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n            } else {\n                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n            }\n\n            return result;\n        }\n    }\n    result.push(polygon);\n\n    return result;\n}\n\n/**\n * Remove collinear points in the polygon.\n * @method removeCollinearPoints\n * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.\n * @return {Number}           The number of points removed\n */\nfunction polygonRemoveCollinearPoints(polygon, precision){\n    var num = 0;\n    for(var i=polygon.length-1; polygon.length>3 && i>=0; --i){\n        if(collinear(polygonAt(polygon, i-1),polygonAt(polygon, i),polygonAt(polygon, i+1),precision)){\n            // Remove the middle point\n            polygon.splice(i%polygon.length,1);\n            num++;\n        }\n    }\n    return num;\n}\n\n/**\n * Remove duplicate points in the polygon.\n * @method removeDuplicatePoints\n * @param  {Number} [precision] The threshold to use when determining whether two points are the same. Use zero for best precision.\n */\nfunction polygonRemoveDuplicatePoints(polygon, precision){\n    for(var i=polygon.length-1; i>=1; --i){\n        var pi = polygon[i];\n        for(var j=i-1; j>=0; --j){\n            if(points_eq(pi, polygon[j], precision)){\n                polygon.splice(i,1);\n                continue;\n            }\n        }\n    }\n}\n\n/**\n * Check if two scalars are equal\n * @static\n * @method eq\n * @param  {Number} a\n * @param  {Number} b\n * @param  {Number} [precision]\n * @return {Boolean}\n */\nfunction scalar_eq(a,b,precision){\n    precision = precision || 0;\n    return Math.abs(a-b) <= precision;\n}\n\n/**\n * Check if two points are equal\n * @static\n * @method points_eq\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Number} [precision]\n * @return {Boolean}\n */\nfunction points_eq(a,b,precision){\n    return scalar_eq(a[0],b[0],precision) && scalar_eq(a[1],b[1],precision);\n}\n"],"sourceRoot":""}